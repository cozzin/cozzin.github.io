[ { "title": "앱 배포 담당자가 겪은 일들 - 긴급 심사부터 예약 배포까지", "url": "/posts/app-store-deployment-experience/", "categories": "iOS", "tags": "iOS, App Store, 배포, App Store Connect", "date": "2025-06-18 03:00:00 +0000", "snippet": "들어가며이번에 App Store 배포를 담당하게 되었습니다. 그 동안은 대부분 정규 릴리즈 담당이었어서 특별한 이슈가 없었는데, 이번에는 여러 번의 배포를 거치면서 많은 것을 배웠습니다.특히 이번 배포는 특별했습니다. 특정 날짜 이후로 기능이 배포되어야 하는 상황이었고, x.x.0 버전은 미리 배포해두고, x.x.1 버전을 스크린샷과 앱 설명을 업데이...", "content": "들어가며이번에 App Store 배포를 담당하게 되었습니다. 그 동안은 대부분 정규 릴리즈 담당이었어서 특별한 이슈가 없었는데, 이번에는 여러 번의 배포를 거치면서 많은 것을 배웠습니다.특히 이번 배포는 특별했습니다. 특정 날짜 이후로 기능이 배포되어야 하는 상황이었고, x.x.0 버전은 미리 배포해두고, x.x.1 버전을 스크린샷과 앱 설명을 업데이트해서 배포해야 했어요.일요일 오전에 배포를 시작하고 싶었고, 금요일 오후에 심사 제출을 했기 때문에 여유로운 상황은 아니었습니다. 그래서 긴급 심사 요청을 하게 되었습니다.그런데 예상치 못한 문제들이 연속으로 발생했습니다. 스크린샷 규정 위반으로 첫 번째 제출이 리젝되었고, 승인 받았던 빌드를 실수로 취소했고, 예약 배포도 제대로 작동하지 않았습니다.이번 글에서는 실제로 겪은 문제들과 해결 방법, 그리고 배운 점들을 배포 과정의 흐름에 따라 정리해보겠습니다.심사 제출 전 준비 과정스크린샷 규정 위반으로 첫 번째 리젝첫 번째로 마주한 문제는 스크린샷 규정이었습니다. 스크린샷은 디자이너에게 받았는데, 가격 정보가 포함되면 안 된다는 사실을 몰랐습니다.“무료”라는 표현이 스크린샷 이미지에 포함되어 있었는데, 이것 때문에 심사에서 반려되었습니다. 가격 정보를 제거하니 심사를 통과했어요.흥미로운 점은 앱 설명에는 가격 정보가 포함되어도 된다는 것입니다. 스크린샷과 앱 설명의 규정이 다르다는 점이 이상하더라고요.특수문자 사용 제한앱 설명에 &lt; 키보드로 입력한 꺾쇠 문자를 넣으면 “사용할 수 없는 단어가 포함되어 있다”는 에러가 발생했습니다.이 문제를 해결하기 위해 &lt;과 비슷한 특수문자를 찾아서 사용했습니다: 〈 (U+2329) - left-pointing angle bracket 〉 (U+232A) - right-pointing angle bracket눈으로 봤을 때는 제대로 표시되었고, App Store Connect의 정책상 제한사항인 것 같습니다.스크린샷 업데이트를 위한 전략비즈니스 내용을 반영하기 위해 빠르게 스크린샷을 바꿔야 하는 상황이 있었습니다. 그런데 앱 버전을 올리지 않고 스크린샷과 앱 설명만 바꾸는 것은 불가능하더라고요.동료의 조언을 듣고 스크린샷 업데이트를 위해 다음 빌드를 미리 만들어두는 전략을 사용했습니다. 동일한 구현에 버전만 바꿔서 빌드를 만들어두고, 앞선 버전의 심사가 완료된 직후 업데이트된 스크린샷과 설명으로 심사 요청을 했습니다.이 방법 덕분에 빠른 스크린샷 업데이트가 가능했어요.긴급 심사스크린샷과 앱 설명을 업데이트한 후 긴급 심사를 요청했습니다. 남들이 진행하는 것을 보기만 했는데 직접 요청한 것은 처음이었습니다. 예전에는 긴급 심사가 필요한 이유를 메시지로 작성할 수 있었던 것 같은데, 지금은 그런 입력란이 없어졌더라고요.현재는 Apple Developer Contact 페이지에서 앱 심사 &gt; 빠른 앱 심사 요청 &gt; 앱 심사 문의 &gt; App Information에서 App Name과 Platform만 입력하면 끝입니다.처음에는 스크린샷과 앱 설명에 규정 위반 사항이 있어서 반려되었는데, 수정해서 다시 제출했을 때는 1~2시간 안에 승인해주더라고요. 긴급 심사의 효과를 직접 체감할 수 있었습니다.공유하기 부끄럽지만 긴급 심사를 통해 승인되었던 것을 실수로 취소했습니다. 자동화 스크립트 실행 중 실수로 제출이 취소되었습니다… 순간 식은땀나고 아주 당황했어요. 다행히 다시 제출했을 때 1시간 내로 승인되었습니다.예약 배포와 점진적 배포에 대한 오해예약 배포의 불안정성아침 6시에 릴리즈되어야 하는 상황이 있어서 예약 배포를 사용해보았습니다. App Store Connect에서 현지 날짜와 시간으로 정확하게 설정되어 있었는데, 이상하게도 제대로 작동하지 않았어요.“출시 대기 중” 상태로 계속 남아있었습니다. 20분 정도 기다려도 변화가 없어서 결국 “수동으로 버전 출시”로 변경한 후 직접 출시 시작을 했습니다.예약 배포 기능은 편리해 보이지만 가끔은 안정적이지 않은 것 같습니다. 여러번 해본 것은 아니라서 개인 프로젝트에서 나중에 다시 써보려고 합니다.점진적 배포에 대한 오해점진적 배포에 대해서는 완전히 잘못 알고 있었습니다. 처음에는 마치 A/B 테스트처럼 App Store에서도 점진적으로 유저에게 보여진다고 생각했어요.실제로는 App Store에는 모든 유저에게 즉시 공개되고, 자동 업데이트를 허용한 유저에게만 점진적으로 배포되는 기능이었습니다.이 점을 제대로 이해하지 못하고 있었던 게 큰 오해였네요.재제출 과정에서 발견한 주의사항들앱 내 이벤트 취소 시 주의사항앱 심사 제출을 취소할 때 주의해야 할 점을 발견했습니다. 특정 마케팅 이벤트가 앱 내 이벤트로 등록되어 있었는데, 앱 심사 제출을 취소하면서 앱 내 이벤트도 함께 취소되었습니다.출시를 취소할 때는 심사 대상에 앱 내 이벤트가 있었는지 확인해보고, 있다면 마케팅 담당자에게 미리 알려주는 것이 좋겠습니다.Apple 심사 속도 개선긴급 심사가 아니더라도 24시간 이내에 심사 등록부터 배포까지 가능했습니다. 예전에 비해 Apple의 심사 속도가 빨라졌다는 얘기를 몇 년 전부터 들었는데, 실제로 체감할 수 있었습니다.앱 카테고리, 심사 복잡도 등 여러 요인이 있을 수 있겠지만, 전반적으로 심사 속도가 개선된 것 같습니다.배포 담당자로서의 배움중요한 배포였어서 걱정도 있었고 압박감을 많이 느꼈습니다. 그래도 이번 배포를 거치면서 많은 것을 배웠습니다. 특히 App Store의 복잡한 정책들과 예상치 못한 제한사항들을 직접 경험하면서, 사전 준비의 중요성을 깨달았습니다.주요 배운 점들을 정리하면: 스크린샷 규정: 가격 정보 포함 금지, 앱 설명과는 다른 규정 긴급 심사: 메시지 입력란 없음, Apple Developer Contact에서 별도 요청 스크린샷 업데이트: 새 버전 필요, 미리 빌드 준비 전략 특수문자 제한: 유니코드 특수문자로 대체 가능 예약 배포: 이번 경험에서 불안정했음 점진적 배포: App Store 노출과 무관, 자동 업데이트 사용자에게만 적용 앱 내 이벤트: 심사 취소 시 함께 취소됨, 사전 협의 필요갑자기 생각났는데 앱스토어 규정 위반에 걸릴게 없는지 미리 확인해주는 서비스가 있으면 좋을 것도 같네요.마무리App Store 배포는 단순히 빌드를 업로드하고 심사를 기다리는 것이 아니라, 다양한 정책과 제한사항을 이해하고 대응해야 한다고 생각해요. 이번에도 팀원들의 도움을 받으며 많은 것을 배울 수 있었습니다. 이슈들을 겪으면서 예전에는 운이 없었다고 생각했던거 같은데, 요즘에는 이상하게 긍정적으로 변해서 좋은 경험과 추억거리가 쌓여서 기분이 좋기도 합니다. 아무튼 다음번 배포 때는 좀 더 능숙할거라는 희망을 가져봅니다.참고 자료 Apple Developer Contact Unicode Character Database - U+2329 Unicode Character Database - U+232A" }, { "title": "Experiences of an App Store Deployment Manager - From Expedited Review to Scheduled Deployment", "url": "/posts/app-store-deployment-experience-en/", "categories": "iOS", "tags": "iOS, App Store, Deployment, App Store Connect", "date": "2025-06-18 03:00:00 +0000", "snippet": "IntroductionI recently took on the role of App Store deployment manager. While I had mostly handled regular releases before without any special issues, this time I learned a lot through multiple de...", "content": "IntroductionI recently took on the role of App Store deployment manager. While I had mostly handled regular releases before without any special issues, this time I learned a lot through multiple deployment cycles.This deployment was particularly special. We needed to deploy features after a specific date, with x.x.0 version pre-deployed and x.x.1 version to be deployed with updated screenshots and app descriptions.I wanted to start deployment on Sunday morning and submitted for review on Friday afternoon, so it wasn’t a relaxed situation. That’s why I requested an expedited review.However, unexpected problems occurred continuously. The first submission was rejected due to screenshot regulation violations, I accidentally cancelled an approved build, and scheduled deployment didn’t work properly.In this post, I’ll organize the actual problems I encountered, solutions, and lessons learned according to the deployment process flow.Pre-Submission Preparation ProcessFirst Rejection Due to Screenshot Regulation ViolationThe first problem I encountered was screenshot regulations. I received screenshots from the designer but didn’t know that price information couldn’t be included.The word “Free” was included in the screenshot image, which caused the review to be rejected. After removing the price information, the review passed.Interestingly, price information can be included in app descriptions. It’s strange that the regulations for screenshots and app descriptions are different.Special Character Usage RestrictionsWhen I tried to include &lt; characters typed from the keyboard in the app description, I got an error saying “contains words that cannot be used”.To solve this problem, I found and used special characters similar to &lt;: 〈 (U+2329) - left-pointing angle bracket 〉 (U+232A) - right-pointing angle bracketThey looked properly displayed to the eye, and it seems to be a policy restriction of App Store Connect.Strategy for Screenshot UpdatesThere was a situation where I needed to quickly change screenshots to reflect business content. However, it was impossible to change only screenshots and app descriptions without updating the app version.Following a colleague’s advice, I used the strategy of preparing the next build in advance for screenshot updates. I created a build with only the version changed from the same implementation, and requested a review with updated screenshots and descriptions immediately after the previous version’s review was completed.This method made rapid screenshot updates possible.Expedited ReviewAfter updating screenshots and app descriptions, I requested an expedited review. I had only seen others do it before, but this was my first time requesting it directly. It seems like in the past you could write a message explaining why expedited review was needed, but now that input field is gone.Currently, on the Apple Developer Contact page, you just need to enter App Name and Platform in App Review &gt; Request Expedited App Review &gt; App Review Inquiry &gt; App Information.Initially, the review was rejected due to regulation violations in screenshots and app descriptions, but when I resubmitted after fixing them, they were approved within 1-2 hours. I could directly feel the effect of expedited review.I’m embarrassed to share this, but I accidentally cancelled an approved expedited review. The submission was cancelled due to a mistake while running an automation script… I was sweating and very surprised at the moment. Fortunately, when I resubmitted, it was approved within 1 hour.Misunderstandings About Scheduled Deployment and Gradual RolloutInstability of Scheduled DeploymentThere was a situation where release was needed at 6 AM, so I tried using scheduled deployment. It was set exactly with local date and time in App Store Connect, but strangely it didn’t work properly.It remained in “Pending Release” status. After waiting about 20 minutes with no change, I finally changed it to “Manually Release Version” and started the release directly.The scheduled deployment feature seems convenient but sometimes unstable. I haven’t tried it many times, so I plan to try it again later in personal projects.Misunderstanding About Gradual RolloutI was completely wrong about gradual rollout. Initially, I thought it would be shown to users gradually on the App Store, like A/B testing.Actually, it’s immediately visible to all users on the App Store, and the gradual rollout feature only applies to users who allow automatic updates.This was a big misunderstanding because I didn’t properly understand this point.Precautions Discovered During Resubmission ProcessPrecautions When Cancelling In-App EventsI discovered something to be careful about when cancelling app review submissions. A specific marketing event was registered as an in-app event, and when I cancelled the app review submission, the in-app event was also cancelled.When cancelling a release, it’s good to check if there were in-app events in the review target, and if there were, notify the marketing team in advance.Apple Review Speed ImprovementEven without expedited review, it was possible to go from review registration to deployment within 24 hours. I had heard that Apple’s review speed had improved compared to before, and I could actually feel it.There could be various factors like app category, review complexity, etc., but overall the review speed seems to have improved.Lessons as a Deployment ManagerIt was an important deployment, so I was worried and felt a lot of pressure. Still, I learned a lot through this deployment process. I especially realized the importance of advance preparation through direct experience with App Store’s complex policies and unexpected restrictions.Key lessons learned: Screenshot Regulations: Price information prohibited, different from app description regulations Expedited Review: No message input field, separate request through Apple Developer Contact Screenshot Updates: New version required, prepare build in advance strategy Special Character Restrictions: Can be replaced with Unicode special characters Scheduled Deployment: Unstable in this experience Gradual Rollout: Unrelated to App Store exposure, only applies to automatic update users In-App Events: Cancelled together when review is cancelled, advance consultation neededIt suddenly occurred to me that it would be nice to have a service that checks in advance whether there’s anything that would violate App Store regulations.ConclusionI think App Store deployment is not just uploading builds and waiting for review, but a complex process that requires understanding and responding to various policies and restrictions. This time too, I learned a lot with the help of team members. While experiencing issues, I used to think I was unlucky, but these days I’ve strangely become more positive, so I feel good about accumulating good experiences and memories. Anyway, I have hope that I’ll be more skilled in the next deployment.References Apple Developer Contact Unicode Character Database - U+2329 Unicode Character Database - U+232A" }, { "title": "[코드숨] 스프링 회고", "url": "/posts/codesoom-8week/", "categories": "Spring", "tags": "Spring, Docs", "date": "2022-08-28 06:00:00 +0000", "snippet": "8주간의 코드숨 스프링 과정이 끝났습니다!매일 저녁마다 해야 하는 과제가 사라진다는 마음에 후련하기도 하고, 더 많이 배우지 못한 것에 대한 아쉬움도 느껴지네요.이번 글에서는 8주차 회고 겸 전체 과정을 회고하겠습니다.8주차 회고 - 배포 준비8주차에는 SpringDocs와 배포 준비가 주제였습니다. Swagger가 아닌 SpringDocs로 문서화 ...", "content": "8주간의 코드숨 스프링 과정이 끝났습니다!매일 저녁마다 해야 하는 과제가 사라진다는 마음에 후련하기도 하고, 더 많이 배우지 못한 것에 대한 아쉬움도 느껴지네요.이번 글에서는 8주차 회고 겸 전체 과정을 회고하겠습니다.8주차 회고 - 배포 준비8주차에는 SpringDocs와 배포 준비가 주제였습니다. Swagger가 아닌 SpringDocs로 문서화 해보는 경험이 새로웠습니다.Docs 만드는 방식은 팀마다 다를 것으로 생각해서 이 과제에서는 가볍게 실험해보는 정도까지만 진행했습니다.대신 배포하는 것에 좀 더 많은 시간을 할애했습니다.이미 배포 프로세스가 갖춰진 팀에서는 배포할 때 별다른 수고를 하지 않아도 될 텐데요.그래서 이렇게 아무것도 세팅되지 않은 환경에서 배포하는 게 중요한 경험이라고 생각했습니다.오랜만에 AWS에 인스턴스도 만들었습니다. 그리고 띄워둔 서버에 API 호출해보는 과정이 즐거웠습니다.이전에 사용해보지 못했던 docker를 잠깐 사용해봤는데, 굉장히 편리한 도구라는 것을 알게 되었습니다.이렇게 간단한 방식으로 배포까지 해보니 토이 프로젝트를 만들어서 배포할 수 있겠다는 생각이 들었습니다.학습하는 습관4주차 까지는 주제를 정하고 탐구하는 시간을 충분히 가졌는데, 그 시간을 통해서 많은 경험을 얻을 수 있었습니다.그 이후로는 개인적인 일정 때문에 충분한 시간을 들여서 탐구하지는 못했습니다.하지만 매일 저녁이 되면 무엇이 되든 학습하는 습관이 생겼습니다.어떤 일을 잘게 나눠서 목표로 잡는 것도 좋지만, 시간을 자체를 할애하는 게 중요하다는 것을 알게 되었습니다.백엔드 개발 첫 걸음백엔드 공부를 왜 하는가 하는 질문을 몇 번 들었습니다. 이전에도 내가 원하는 앱을 만들기 위해서 작은 기능을 하는 서버를 구동한 적이 몇 번 있었습니다.그때마다 서버 구현을 제대로 못 하거나 데이터베이스 지식이 부족해서 기능을 제한시키고, 결국에는 매력적인 서비스를 만들지 못한 경험을 여러 차례 했어요.팀을 이뤄서 프로젝트를 만드는 것도 한 번씩 하고 있지만, 제가 원하는 제대로 된 서비스를 설계하려면 백엔드 지식이 필요하다고 판단했습니다.iOS 개발로만 주로 경력을 쌓아와서 iOS 개발하고 학습하는 데는 큰 어려움이 없습니다. 하지만 10년, 20년, 그리고 평생 IT 업계에서 일하려면 서버 개발에 대한 막연한 두려움을 제거할 필요가 있다고 생각했어요.이번 기회를 통해서 막연한 두려움을 제거하고, 모르는 것을 모르는 단계에서 모르는 것을 아는 단계로 진입하게 되었다고 생각합니다.8주간 도움 주신 많은 분께 감사하고, 스스로 계속 발전할 기회를 주는 나 자신에게도 고맙다고 전하고 싶습니다.특별히 코스를 시작할 수 있게 용기를 주고 지지해준 아내에게 많은 고마움을 전합니다." }, { "title": "AWS EC2 생성하고 Github Repository Clone하기", "url": "/posts/create-aws-ec2-instance/", "categories": "Spring", "tags": "Spring, AWS, EC2", "date": "2022-08-24 11:00:00 +0000", "snippet": "오랜만에 AWS에 EC2 서버 띄우려고 합니다.https://velog.io/@18k7102dy/devops-mono-5, https://velog.io/@18k7102dy/Docker-Spring-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-Docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95...", "content": "오랜만에 AWS에 EC2 서버 띄우려고 합니다.https://velog.io/@18k7102dy/devops-mono-5, https://velog.io/@18k7102dy/Docker-Spring-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-Docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B4%85%EC%8B%9C%EB%8B%A4이 글 보면서 따라갑니다.위의 글이 더 정확할 수 있습니다. 그래도 미래의 저를 위해서 기록해보겠습니다.EC2 instance 생성하기잊어버린 비밀번호를 찾고ㅋㅋ EC2로 검색해서 들어왔습니다.EC2 instance 생성 화면이 달라진 것 같아서 캡쳐하면서 진행합니다.기본 설정과 동일하게 Amazon Linux 를 선택Network settings도 기본으로 둡니다.혹시 나중에 이슈 생기면 수정할 예정새로운 key piar 생성하겠습니다.자동으로 다운되는 pem 파일은 로컬에 잘 보관하기프리티어는 30GiB까지 무료일단 이렇게 고고1초만에 만들어졌다…Security Group 설정하기SSH만 기본적으로 설정된 것을 볼 수 있습니다.Edit inbound rules를 선택해서 HTTP 통신을 위한 80포트도 추가해줍니다.Add rule을 선택합니다.HTTP 선택!ssh 접속하기pem은 public key file인데 실행권한을 줘야합니다.chmod 400 ./spring-server-key-pair.pem만약 실행권한이 없으면 아래와 같은 에러를 만나게 됩니다.Permission denied (publickey,gssapi-keyex,gssapi-with-mic)권한을 설정해줬으면 아래 명령어를 실행해서 ssh통해서 서버에 접속합니다.ssh -i ./spring-server-key-pair.pem ec2-user@&lt;Public-IP&gt;서버 환경설정sudo yum update# git 설치sudo yum install git# docker 설치sudo yum install dockerServer deploy key를 Github Repository에 등록key 생성ssh-keygen -t rsakey 복사cd .sshcat id_rsa.pubGihub Setting &gt; Deploy keys &gt; Add deploy key복사해둔 key를 붙여넣고 Add key 해주시면 됩니다.Server deploy key를 Github Account에 등록ssh-keygen -t rsa -C &lt;your github email&gt;cat id_rsa.pub서버에 git clonecd ~git clone &lt;your address of repository (SSH Address)&gt;참고자료 https://velog.io/@18k7102dy/devops-mono-5 https://velog.io/@18k7102dy/Docker-Spring-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-Docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B4%85%EC%8B%9C%EB%8B%A4" }, { "title": "[코드숨] 스프링 7주차 회고 - 보안", "url": "/posts/codesoom-7week/", "categories": "Spring", "tags": "Spring, Security", "date": "2022-08-24 00:00:00 +0000", "snippet": " Authentication: 몇 년 전에 사이드 프로젝트를 위한 서버를 만든 적 있었는데, 인증을 구현하는 것이 큰 관문이었다. 물론 지금도 쉽지는 않지만 이제 내 서비스를 만들 수 있겠다는 생각이 든다. 암호화: 복호화되지 않는 암호화에 대해서 이해가 잘 되지 않았어서 좀 더 살펴봤다.간단히 말하면 해쉬 값 비교를 통해 동등성을 검증하는 방식이...", "content": " Authentication: 몇 년 전에 사이드 프로젝트를 위한 서버를 만든 적 있었는데, 인증을 구현하는 것이 큰 관문이었다. 물론 지금도 쉽지는 않지만 이제 내 서비스를 만들 수 있겠다는 생각이 든다. 암호화: 복호화되지 않는 암호화에 대해서 이해가 잘 되지 않았어서 좀 더 살펴봤다.간단히 말하면 해쉬 값 비교를 통해 동등성을 검증하는 방식이다.계정 정보 보관은 여전히 두려운 주제이지만 서버개발에서 피해갈 수 없는 부분이다. 리뷰 요청: 지난주 중반까지 PR 리뷰가 되지 않고 있었는데, 따로 요청을 드리지 않았다.회사일이 바쁘기도 해서 하루하루 미루다보니 3일 정도 지나있었다.다른 일을 할 때도 조금 지연되었을 때 게으름과 걱정을 이겨내고 바로 도움을 요청하자.도움을 늦게 요청하면 나만 손해보게 된다." }, { "title": "[코드숨] 스프링 6주차 회고 - 로그인", "url": "/posts/codesoom-6week/", "categories": "Spring", "tags": "Spring, Login", "date": "2022-08-15 08:59:00 +0000", "snippet": "요약지난주는 JWT 이용해서 로그인 구현하는 과제를 수행했습니다.혼자 사이드 프로젝트를 수행할 때 로그인 기능을 만들 때 어려움을 겪었었는데,JWT 토큰을 만들고 주고 받는걸 구현해볼 수 있어서 흥미로웠습니다.다음에 로그인 기능을 구현할 때 써먹을 수 있을 것 같아서 기대됩니다.아래는 이번 주에 알게된 2가지 개념입니다.Lombok 사용시 주의할 점J...", "content": "요약지난주는 JWT 이용해서 로그인 구현하는 과제를 수행했습니다.혼자 사이드 프로젝트를 수행할 때 로그인 기능을 만들 때 어려움을 겪었었는데,JWT 토큰을 만들고 주고 받는걸 구현해볼 수 있어서 흥미로웠습니다.다음에 로그인 기능을 구현할 때 써먹을 수 있을 것 같아서 기대됩니다.아래는 이번 주에 알게된 2가지 개념입니다.Lombok 사용시 주의할 점Java에서 모델을 다룰 때 lombok 이라는 라이브러리를 사용해서 Getter, Setter를 자동으로 만들어 줄 수 있습니다.재밌는 점은 이런 메타 프로그래밍 기법을 사용하면 Code Generator 통해서 생성된 코드를 직접 커밋하는 것은 아니라는 점 입니다.lombok 사용할 때는 주의할 점이 있습니다. @Setter 사용 자제하기 클래스 레벨에서 사용하게 되면 모든 필드들이 언제든지 변경될 수 있는 상태가 됩니다. Setter가 많아지면 작성자의 의도를 드러내기 힘들어 집니다. constructor나 @Builder 통해서 세팅해주는 것이 좋습니다. @AllArgsConstructor 사용 자제하기 @AllArgsConstructor는 클래스 내부의 필드들을 위한 constructor를 자동으로 만들어주는 간편한 기능입니다. 필드 순서가 변경되었을 떄 constructor의 필드 순서도 변경될 수 있습니다. 순서가 변경된 필드의 타입이 같은 경우 의도치 않은 동작의 변경이 있을 수 있습니다. @AllArgsConstructor를 쓰지말고 직접 constructor를 생성하는 것이 좋습니다. @NoArgsConstructor 사용하지 않는 방법도 있음 Spring 통해서 DTO로 변환시키는 과정에서 HttpMessageConverter가 모델로 매핑해주는데요. 이럴 떄 깡통 객체를 먼저 생성해두고 해당 필드에 값을 매핑해줍니다. 그래서 argument가 없는 constructor가 필요하게 되고 @NoArgsConstructor를 사용하게 됩니다. 이럴 때 매핑이 필요한 필드가 들어있는 constructor를 직접 구현하고 @JsonCreator를 붙여주면 HttpMessageConverter가 해당 constructor를 사용하게 됩니다. 마커 인터페이스 패턴아샬님의 강의에서는 mockito 통해서 테스트를 위한 의존 객체를 mocking 하는 방식을 사용합니다.하지만 이 방식이 번거롭기도 하고, 모든 경우의 수에 mocking을 할 것 인가? 라는 고민이 한가지 있었고,테스트에서 input - output을 다 정의해 두더라도 미래에 언제든지 해당 클래스의 스펙이 변경될 수 있으니까 유지보수하기 어려운 테스트 코드라는 생각을 했습니다.그래서 새로 작성하는 테스트 코드에서는 mocking을 쓰지 않고 작업을 하고 있습니다.Repository도 테스트 코드에서 사용할 것을 직접 구현해서 주입해줬습니다.그런데 흥미롭게도 아래와 같은 코드를 제안해주셨습니다.- public class InMemoryUserRepository implements UserRepository {+ public class InMemoryUserRepository implements UserRepository, TestOnly {TestOnly는 아무런 구현도 제약하고 있지 않는 interface 입니다.단지 어떤 클래스가 테스트 코드에서만 사용되는 것을 드러내는 장치입니다.기존에는 추상화된 객체에 method 호출이 필요할 때 interface 를 사용한다고만 생각했던 것 같습니다. 어떤 객체의 의도를 드러낸다는 접근이 신선하게 느껴졌어요.앞으로도 유용하게 쓸 것 같습니다." }, { "title": "[코드숨] 스프링 5주차 회고 - 유효성 검사", "url": "/posts/codesoom-5week/", "categories": "Spring", "tags": "Spring, Validation", "date": "2022-08-08 10:00:00 +0000", "snippet": "이번 주는 시간을 충분히 사용하지 못해서 아쉽지만, 아쉬운대로 회고하고 기록을 남겨본다.유효성 검사이번 주 주제는 유효성 검사였다. 앱 개발할 때 적절한 View를 터치했는지, 적절한 정보를 전달했는지 확인하는 것과 비슷하다.API 서버는 Request가 적절한 양식으로 입력되었는지 확인해야 한다. spring-boot-starter-validatio...", "content": "이번 주는 시간을 충분히 사용하지 못해서 아쉽지만, 아쉬운대로 회고하고 기록을 남겨본다.유효성 검사이번 주 주제는 유효성 검사였다. 앱 개발할 때 적절한 View를 터치했는지, 적절한 정보를 전달했는지 확인하는 것과 비슷하다.API 서버는 Request가 적절한 양식으로 입력되었는지 확인해야 한다. spring-boot-starter-validation 지루할 수 있는 이 과정을 간편하게 처리해준다.Controller 외부에서 전달받은 DTO가 적절한 양식인지 확인해주는데, 유효성을 검사하고 싶은 필드에 어노테이션을 지정하면 된다.아래는 https://spring.io/guides/gs/validating-form-input/ 예제를 빌려왔다.public class PersonForm {\t@NotNull\t@Size(min=2, max=30)\tprivate String name;\t@NotNull\t@Min(18)\tprivate Integer age;}그런데 유효성 검사를 아무때나 해주는건 아니다. Controller의 파라미터에 @Valid 라는 어노테이션을 지정해두면 Spring이 Controller에 파라미터를 전달할 떄 유효성을 먼저 검사한다.유효하지 않은 모델이라면 MethodArgumentNotValidException 예외를 던진다.@Controllerpublic class WebController implements WebMvcConfigurer {\t@PostMapping(\"/\")\tpublic String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) {\t\tif (bindingResult.hasErrors()) {\t\t\treturn \"form\";\t\t}\t\treturn \"redirect:/results\";\t}}iOS 개발에도 도움이 될 것 같다유효성 검사를 위한 귀찮은 작업을 줄여줘서 너무 좋다. 스프링에서 이렇게 좋은 기술을 발견하면 iOS 개발에도 어떻게 하면 가져올 수 있을까 고민이 된다.Swift에는 어노테이션과 동일한 것은 아니지만 약간 비슷한 방식으로 argument에 property wrapper를 적용할 수 있다.유효성 검사를 위한 기능을 만들 때 이런 아이디어를 실험해보면 좋겠다.요즘은 SDK 개발을 하는데 앱 개발 입장에서는 SDK도 일종의 서버가 된다. 그래서 그런지 차용해올 아이디어가 꽤 있는 것 같다.다른 플랫폼의 기술을 배우는건 시야를 넓혀주는 좋은 방법이라 생각한다.일정아쉽지만 다른 일정 때문에 이번 주는 과제 해결하는데 3일 정도만 사용할 수 있었다. 시간을 더 효율적으로 사용하는 방법을 배워야 겠다. 사이드 프로젝트로 진행하고 있는 타이머 앱의 필요성을 한번 더 느꼈다.하고 싶은건 많고 시간은 부족한 사람들이 많지 않을까?아무튼 다음 주도 시간이 넉넉하진 않다. 지치지 않고 계속 학습할 방법을 찾아가야겠다." }, { "title": "@WebMvcTest 장단점", "url": "/posts/WebMvcTest/", "categories": "Spring", "tags": "Spring, MVC, Test", "date": "2022-08-02 12:00:00 +0000", "snippet": "코드숨 과제를 보면 @WebMvcTest 어노테이션을 활용해서 테스트하고 있다. 간편하게 테스트할 수 있는 기능을 제공해주지만 나는 과제를 진행하면서 이 어노테이션을 쓰지 않았다. 일단 내가 만들고 싶은 테스트 구조에서는 위의 어노테이션이 제대로 작동하지 않았기 때문에 쓸 수 없었다.Nested Test에서 사용 불가능Spring 5.3 부터 Nest...", "content": "코드숨 과제를 보면 @WebMvcTest 어노테이션을 활용해서 테스트하고 있다. 간편하게 테스트할 수 있는 기능을 제공해주지만 나는 과제를 진행하면서 이 어노테이션을 쓰지 않았다. 일단 내가 만들고 싶은 테스트 구조에서는 위의 어노테이션이 제대로 작동하지 않았기 때문에 쓸 수 없었다.Nested Test에서 사용 불가능Spring 5.3 부터 Nested Test에서 사용 가능하게 되었다고 한다. 과제 프로젝트의 환경은 Spring-core:5.2.10 을 사용하고 있어서 여기서 테스트 해보진 못했다.작업 중인 프로젝트에서는 구조화된 테스트를 작성할지 WebMvcTest를 사용할지 둘 중 하나를 선택해야하는 상황이다.Spring에 PR 올라와있는걸 보면 searchEnclosingClass() 이라는 것을 구현해서 테스트 가능하게 만들었다고 한다.구체적인 코드를 이해해보고 싶었는데, 맥락을 몰라서 그런지 이해하기가 굉장히 어렵다… 🥲 대략 이해한 내용은 Nested 테스트 상황을 고려해서 Root 클래스의 Context도 고려하는 방식으로 바뀐 것 같다.WebMvcTest의 장점구조화된 테스트를 작성하지 않는다고 가정하고 한번 탐구해보자. WebMvcTest를 사람들이 사용하는 이유가 있을 것이다. If you want to focus only on the web layer and not start a complete ApplicationContext, consider using @WebMvcTest instead.spring 문서를 보면 @SpringBootTest는 스프링 서버를 전부 띄워서 테스트하는 반면,@WebMvcTest는 Web Layer만 테스트할 수 있도록 도와준다고 한다. 그리고 @WebMvcTest(UserController.class) 같이 Controller를 직접 지정하면 필요한 Context만 생성하게 된다.@SpringBootTest 보다는 좀 더 빠르다는 느낌을 받았다.Auto-configured Spring MVC Tests 자동으로 의존하는 컴포넌트들을 주입해주는 것도 장점이라고 한다.의존성을 하나하나 지정해주는 것을 나는 선호하지만, 이런 컴포넌트들이 굉장히 많아졌을 때 유연하게 대처할 수 있을 것 같다.WebMvcTest의 한계 완전한 통합 테스트가 필요할 떄가 있다 그럴 때는 @SpringBootTest를 사용하자 앞서 말한 구조화된 테스트를 작성하기 어렵다 @SpringBootTest 보다는 빠르다고 하지만 유닛 테스트에 비하면 여전히 느린듯 하다.의문 Controller에 필요한 의존성은 ApplicationContext 통해서 생성하고, @BeforeEach 에서 직접 Controller를 참조해줄 수 없을까?" }, { "title": "Github Comment로 CircleCI 실행시키기", "url": "/posts/trigger-circle-ci-from-github-comment/", "categories": "CI", "tags": "Github, Github Action, CircleCI, Deployment Automation", "date": "2022-06-12 01:47:00 +0000", "snippet": "안녕하세요! 요즘에는 Sendbird Chat 배포 자동화를 수정하고 있습니다.기존에는 Jira 티켓 생성 -&gt; PM 승인 -&gt; 빌드 -&gt; 배포 전체 프로세스를 자동화로 관리하고 있었는데요.4단계의 과정에서 에러가 끼어들면 전체 프로세스를 다시 시작해야하는 번거로움이 있었습니다.그리고 master 브랜치에 tag가 만들어지는 것을 트리...", "content": "안녕하세요! 요즘에는 Sendbird Chat 배포 자동화를 수정하고 있습니다.기존에는 Jira 티켓 생성 -&gt; PM 승인 -&gt; 빌드 -&gt; 배포 전체 프로세스를 자동화로 관리하고 있었는데요.4단계의 과정에서 에러가 끼어들면 전체 프로세스를 다시 시작해야하는 번거로움이 있었습니다.그리고 master 브랜치에 tag가 만들어지는 것을 트리거로 배포 배포 프로세스가 작동시켰는데,배포 과정에서 에러가 발생하면 tag를 삭제하고 release 브랜치를 다시 만들어야하는 어려움이 있었습니다.목표 빌드 -&gt; 배포 workflow만 분리하기 release 브랜치에서 위의 workflow 트리거할 수 있게 해주자원하는 때에 CircleCI Workflow 실행시키기일단은 CircleCI Job을 매뉴얼하게 시작시키는 방법을 알아보겠습니다.제일 원시적으로 CircleCI에 들어가서 버튼을 누르면 배포가 실행되게 할까 했는데, 생각보다 매뉴얼하게 실행하는게 귀찮습니다.How to trigger a workflow via CircleCI API v2글을 보면 어떻게 매뉴얼하게 pipeline을 실행시키는지 알 수 있습니다. config.yml 파일의 상단에 파라미터를 세팅할 수 있고, 그 파라미터가 true 인지 조건을 걸어두는 방법입니다. 솔직히 이것도 귀찮긴 하지만… 다른 방법을 못찾았어요.parameters: run_workflow_build_and_release: default: false type: booleanworkflows: version: 2 build: when: &lt;&lt; pipeline.parameters.run_workflow_build_and_release &gt;&gt; jobs: - job_a(when 으로 조건 설정해뒀는데, condition에 대해 더 살펴보실 분은 Conditional steps in jobs and conditional workflows 추천 드립니다.)혹시나 기존 다른 workflow는 실행하고 싶지 않다! 하면 아래와 같이 not으로 조건 추가할 수도 있습니다.build-and-test-swift:when: or: - not: &lt;&lt; pipeline.parameters.run_workflow_build_and_release &gt;&gt;이렇게 config.yml 파일을 수정해놓고 CircleCI에 작업 프로젝트 &gt; 작업 브랜치로 들어가보면 Trigger Pipline 이라는 버튼을 볼 수 있습니다.Trigger Pipline을 누르면 어떤 파라미터를 넣어서 Pipeline을 시작할지 설정할 수 있습니다.하지만 run_workflow_build_and_release 대략 이런식으로 생긴 파라미터를 직접 넣어야하는상당한 불편함이 있습니다…CircleCI API 통해서 Workflow 실행시키기Trigger a new pipeline 여기를 보면 API를 통해서 pipeline을 트리거할 수 있습니다. 여기에 파라미터를 추가하면 원하는 workflow만 실행시킬 수 있는 것이죠…!이쯤되서 말씀드리면 제가 생각하는 큰 그림은 Github Comment 추가 -&gt; Github Action 발동 -&gt; Circle API 실행 -&gt; 배포 자동화 실행 입니다.위의 사이트로 들어가보면 Shell+Curl 에서 어떻게 구성하면 되는지 예시가 나와 있습니다.저에게 맞는 방식으로 약간 수정해보면 다음과 같습니다.curl --request POST \\ --url https://circleci.com/api/v2/project/gh/org-name/repo-name/pipeline \\ --header 'Circle-Token: CIRCLE_CI_TOKEN' \\ --header 'content-type: application/json' \\ --data '{\"branch\":\"release/4.0.0\",\"parameters\":{\"run_workflow_build_and_release\":true}}'CIRCLE_CI_TOKEN에는 Personal API Token을 전달해줘야 합니다.그러면 아래와 같이 response가 넘어오고 pipeline이 실행된 것을 확인할 수 있습니다.{ \"number\" : 1234, \"state\" : \"pending\", \"id\" : \"abcdefgh-39e8-1ab2-abcd-a385abcdefgh\", \"created_at\" : \"2022-06-09T14:26:39.437Z\"}CircleCI API를 Github Comment로 작동시키기PR의 브랜치 정보 가져오기매번 CircleCI 들어가서 파라미터 넣어주기가 너무 귀찮으니까, github pr에 comment로 명령어를 날리면 CircleCI API가 실행되도록 해보겠습니다.예약어가 담긴 Comment 추가 -&gt; Github Action 실행 하는 방법을 자세히 알고 싶은 분은 github action으로 comment bot 만들기 글을 참고하시면 됩니다..github/workflows 아래에 다음과 같은 pr-comment-bot.yml 파일을 만들었습니다.유형이 pr이고, 코멘트에 /bot deploy가 있을 때 배포되는 조건입니다.workflow로 브랜치 정보가 들어올테니 코멘트에서 따로 브랜치 입력할 필요가 없습니다!name: PR Comment Boton: issue_comment: types: [created, edited]jobs: pull_request_comment: if: | contains(github.event.comment.html_url, '/pull/') &amp;&amp; contains(github.event.comment.body, '/bot deploy') runs-on: [macos-latest] steps: - name: Deploy id: deploy-circle-ci run: | echo $ DEPLOY_API_RESULT=$(curl --request POST --url https://circleci.com/api/v2/project/gh/organization-name/repository-name/pipeline --header 'Circle-Token: $' --header 'content-type: application/json' --data '{\"branch\":$,\"parameters\":{\"run_workflow_build_and_release\":true}}') echo \"DEPLOY_API_RESULT: ${DEPLOY_API_RESULT}\"이렇게 깔끔하게 사용하고 싶었는데… github.base_ref, github.ref_name가 빈 값으로 들어오네요ㅠ github json으로 들어오는걸 dump 떠보면 좋을 것 같은데요. 이렇게 하면 json 내용이 다 보입니다.jobs: print_variables: runs-on: [macos-latest] steps: - name: Dump GitHub context env: GITHUB_CONTEXT: ${{ toJson(github) }} run: echo \"$GITHUB_CONTEXT\"{ \"token\": \"***\", \"job\": \"print_variables\", \"ref\": \"refs/heads/main\", \"sha\": \"5cb8257ec0b8fd************************\", \"repository\": \"repository\", \"repository_owner\": \"repository_owner\", \"repository_owner_id\": \"repository_owner_id\", \"repositoryUrl\": \"git://github.com/organization_name/repository_name.git\", \"run_id\": \"247965****\", \"repository_id\": \"43168****\", \"actor_id\": \"1164****\", \"actor\": \"cozzin\", \"workflow\": \"PR Comment Bot\", \"head_ref\": \"\", // 이게 비어 있음... \"base_ref\": \"\", // 이게 비어 있음... \"event_name\": \"issue_comment\", \"event\": { \"issue\": { \"body\": \"PR Body!\", \"number\": 2, // 이걸 활용할 수 있지 않을까? } }}head_ref, base_ref는 비어 있는게 명확하게 확인되었고, 아마도 comment created로 접근하면 이 내용이 없는 것 같습니다.github.event.issue.number를 활용해보겠습니다. gh는 github cli 명령어 인데터미널에서 github과 소통을 효율적으로 할 수 있습니다. gh pr checkout {이슈번호}로 요청하면 PR이 있는 브랜치로 checkout 할 수 있습니다! 그리고 git branch --show-current 통해서 현재 브랜치명을 가져왔습니다.- name: Checkout code uses: actions/checkout@v3- run: gh pr checkout $ISSUE env: GITHUB_TOKEN: $ ISSUE: $- name: Get pr head branch run: echo 'PR_HEAD_BRACNH='$(git branch --show-current) &gt;&gt; $GITHUB_ENV아쉽게도 PR이 타켓으로 하는 브랜치를 가져오지는 못했는데요;;일단 현재 브랜치까지는 가져왔으니 좀 더 진행해보겠습니다.(브랜치를 더 효율적으로 가져올 수 있는 방법을 아는 분은 알려주시면 정말 감사하겠습니다ㅠㅠ)PR 브랜치가 release or hotfix 인지 확인하기이렇게 되면 모든 브랜치의 코멘트에서 배포 명령을 실행할 수 있는 상태가 됩니다.거의 그런 일은 없겠지만 실수를 방지하기 위해서 PR의 작업 브랜치가 배포할 수 있는 브랜치인지 확인해보겠습니다.Deploy 단계 전에 아래의 step을 추가하면 됩니다!- name: Check deployable branch run: | if [[ $input == release* ]] || [[ $input == hotfix* ]]; then echo \"it's deployable 🚀\" else echo \"it's not deployable 🙅\" exit 1 fi그러면 배포 하면 안되는 브랜치에서 코멘트 날린 경우에는 아래와 같이 걸러지게 됩니다. 당연히 Deploy step은 실행되지 않아서 실수로 배포되는 경우는 없습니다.결론이제 PR에 코멘트를 입력해서 배포를 시작할 수 있습니다! 브랜치명을 입력할 필요 없고, 배포되어서 안되는 브랜치에서 배포될 일도 없습니다.아래는 github action 전체 코드 입니다.name: PR Comment Boton: issue_comment: types: [created, edited]jobs: pull_request_comment: if: | contains(github.event.comment.html_url, '/pull/') &amp;&amp; contains(github.event.comment.body, '/bot deploy') runs-on: [macos-latest] steps: - name: Add deploy comment uses: actions/github-script@v5 with: github-token: $ script: | github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: \"🐣 Preparing request to circleci\" }) - name: Checkout code uses: actions/checkout@v3 - run: gh pr checkout $ISSUE env: GITHUB_TOKEN: $ ISSUE: $ - name: Get pr head branch id: get-pr-head-branch run: echo ::set-output name=PR_HEAD_BRACNH::$(git branch --show-current) - name: Check deployable branch run: | if [[ $input == release* ]] || [[ $input == hotfix* ]]; then echo \"it's deployable 🚀\" else echo \"it's not deployable 🙅\" exit 1 fi - name: Deploy id: deploy-circle-ci run: | DEPLOY_API_RESULT=$(curl --request POST --url https://circleci.com/api/v2/project/gh/$YOUR_ORGANIZATION/$YOUR_REPOSITORY/pipeline --header 'Circle-Token: $' --header 'content-type: application/json' --data '{\"branch\":\"$\",\"parameters\":{\"run_workflow_build_and_release\":true}}') echo \"DEPLOY_API_RESULT: ${DEPLOY_API_RESULT}\" CIRCLE_CI_JOB_NUMBER=$( jq -r '.number' &lt;&lt;&lt; \"${DEPLOY_API_RESULT}\" ) echo ::set-output name=DEPLOY_COMMENT_BODY::\"https://app.circleci.com/pipelines/github/$YOUR_ORGANIZATION/$YOUR_REPOSITORY/$CIRCLE_CI_JOB_NUMBER\" - name: Add deploy comment uses: actions/github-script@v5 with: github-token: $ script: | github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: \"🕊 Distribution in progress on circleci $\" })아마 서비스 마다 CI 서버를 다양하게 쓸거라서 아래 코드를 동일하게 쓸 수 있는 곳은 많이 없겠지만,여기까지 읽으신 분이라면 다양하게 활용 가능할 것 같습니다.긴 내용 읽어주셔서 감사합니다!!" }, { "title": "[도서] 클린 소프트웨어: Part2. 애자일 설계 (p.107~115)", "url": "/posts/CleanSoftware/", "categories": "", "tags": "", "date": "2022-02-05 03:00:00 +0000", "snippet": " 애자일 팀에서, 큰 그림은 소프트웨어와 함께 발전한다. 각 반복에서 팀은 시스템의 설계를 개 선해 지금 그대로도 충분히 가능한 한 제일 좋은 시스템이 되도록 한다. 나중의 요구사항과 필요에 대해서는 그리 오래 생각하지 않는다. 그리고 내일 필요해질 것이라고 생각하는 기능 을 지원하기 위해 오늘 기반구조(infrastructure)를 짜 맞추려 하지...", "content": " 애자일 팀에서, 큰 그림은 소프트웨어와 함께 발전한다. 각 반복에서 팀은 시스템의 설계를 개 선해 지금 그대로도 충분히 가능한 한 제일 좋은 시스템이 되도록 한다. 나중의 요구사항과 필요에 대해서는 그리 오래 생각하지 않는다. 그리고 내일 필요해질 것이라고 생각하는 기능 을 지원하기 위해 오늘 기반구조(infrastructure)를 짜 맞추려 하지도 않는다. 그보다는，현재 구조에 초점을 두고 더욱 개선하기 위해 노력한다. p.108애자일 설계에 대한 요약이라고 볼 수 있다. 기반구조를 만들어 놓고 기능을 추가하는 방식이 아니다. 나중에 수고가 더 많이 드는 것이 아닌가 하는 의문이 든다.잘못된 설계의 증상 경직성(Rigidity): 설계를 변경하기 어려움 취약성(Fragility): 설계가 망가지기 쉬움. 한 군데 변경 -&gt; 많은 부분이 잘못되는 경향 부동성(Immobility): 설계를 재사용하기 어려움. 다른 시스템에서 유용하게 쓸 수 있는 부분이 있지만 분리하기 어려움. 점착성(Viscosity): 제대로 동작하기 어려움. [소프트웨어 점착성] 변경이 필요할 때 설계를 유지하지 않는 방식이 더 쉬운 경우. [환경의 점착성] 개발 환경 느리고 비효율적인 경우. 불필요한 복잡성(Needless Complexity): 과도한 설계. 현재 시점에서 유용하지 않은 요소가 포함됨. 불필요한 반복(Needless Repetition): 마우스 남용. 같은 코드가 조금씩 다른 형태로 계속 반복되어 나타나면서, 개발자는 추상화된 개념을 잃게 된다. 불투명성(Opacity): 혼란스러운 표현 이 착취는 코드의 작은 부분이 아니라 소프트웨어의 전체 구조로 고루 퍼져 나간다.원칙위의 증상들을 완화시켜주는 원칙들 SRP: 단일 책임 원칙 OCP: 개발 폐쇄 원칙 LSP: 리스코프 치환 원칙 DIP: 의존 관계 역전 원칙 ISP: 인터페이스 분리 원칙 악취와 원칙 아무 악취도 나지 않을 때는 원칙을 적용하지 않는다. p.109Chapter7. 애자일 설계란 무엇인가? “소프트웨어 개발생명주기를 검토한후, 공학 설계의 기준을 실제로 만족시킬유일한 소프트웨어 문서는 소스 코드 목록뿐임을 알 수 있었다.”잭 리브스(Jack Reeves) 결국，소스 코드가 바로 설계다.소프트웨어에서 어떤 것이 잘못되는가? 기존 시스 템은 계속 발전하고 변경되며, 새로운 설계는 그것을 쫓아가야 한다. 새로운 설계가 첫 번째 릴리즈에 이르기도 전에 혹과 궤양이 새로운 설계에 생기는 셈이다.어떻게 보면 아무리 노력해도 언제나 새로운 레거시가 만들어지는 셈이다.무엇이 소프트웨어 부패를 촉진하는가? 변경에 대해서도 탄력적인 설계를 만드는 방 식을 찾아야 하고, 그것이 부패하지 않도록 보호할 수 있는 방식을 사용해야 한다.애자일 팀은 소프트웨어가 부패하도록 내버려두지 않는다 시스템의 설계를 가능한 한 명료하고 단순하게 유지하고, 이것을 많은 단위 테스트와 인수 테스트로 뒷받침한다. 이런 작업을 통해 설계를 유연하고 변경하기 쉬운 것으로 유지할 수 있다.테스트가 설계의 유연함을 돕는다고 한다. 리팩토링할 때 자신감을 심어주기 때문인 것으로 생각된다. 반면 경험이 없는 나는 테스트 코드가 있을 때 테스트 코드를 신경써야 하기 떄문에 쉽다는 느낌은 들지 않았다. 좀 더 경험을 쌓아봐야겠다.‘Copy’ 프로그램" }, { "title": "dynamicMemberLookup를 활용한 Builder", "url": "/posts/DynamicMemberLookupBuilder/", "categories": "", "tags": "", "date": "2021-04-11 11:49:00 +0000", "snippet": "안녕하세요. 이번에는 Builder를 구현해보겠습니다. 빌더 패턴을 구현하기 위해서 목표로 하는 객체 프로퍼티의 set 함수들을 직접 만들어줘야하는 번거로움이 있습니다. 물론 Builder로 한번 작성 후에는 수정이 되지 않는 Immutable 객체를 만들 수 있는 장점이 있지만, UI 객체의 경우 Mutable 객체가 많기 때문에 굳이 이런식의 접근...", "content": "안녕하세요. 이번에는 Builder를 구현해보겠습니다. 빌더 패턴을 구현하기 위해서 목표로 하는 객체 프로퍼티의 set 함수들을 직접 만들어줘야하는 번거로움이 있습니다. 물론 Builder로 한번 작성 후에는 수정이 되지 않는 Immutable 객체를 만들 수 있는 장점이 있지만, UI 객체의 경우 Mutable 객체가 많기 때문에 굳이 이런식의 접근을 하지 않아도 괜찮다고 생각합니다.우아한형제들 기술블로그를 보다가 KeyPath에 대한 내용을 보게 되었습니다. https://woowabros.github.io/swift/2021/02/18/swift-dynamic-features.html 원래 알고 있던 내용들이라고 생각하고 스크롤하면서 보고 있었는데 저런것도 가능한가???!! 싶은 부분을 발견했습니다. 추상적인 빌더를 만들어 놓고 제네릭을 통해서 해당 객체를 변경시키는 코드입니다.let label = UILabel() .builder .text(\"hi\") .textColor(.label) .numberOfLines(0) .build()기존에도 많은분들이 then을 사용해서 객체를 수정하는 것으로 알고 있는데, 이건 좀 더 SwiftUI 스러운 느낌이 나서 좋다고 생각합니다. Builder 패턴 예제로 나오는 모습을 거의 유지하고 있어서 처음 코드를 접한 사람도 빌더 패턴인것을 바로 인식할 수 있다는 장점이 있습니다. 위의 구현을 위해서는 아래와 같은 코드가 필요합니다.@dynamicMemberLookuppublic struct Builder&lt;Base&gt; { private var base: Base public init(_ base: Base) { self.base = base } public subscript&lt;Value&gt;(dynamicMember keyPath: ReferenceWritableKeyPath&lt;Base, Value&gt;) -&gt; ((Value) -&gt; Builder&lt;Base&gt;) { return { value in base[keyPath: keyPath] = value return Builder(base) } } public func build() -&gt; Base { base }}public protocol Buildable { associatedtype Base: AnyObject var builder: Builder&lt;Base&gt; { get }}public extension Buildable where Self: AnyObject { var builder: Builder&lt;Self&gt; { Builder(self) }}extension NSObject: Buildable {}기발하다고 생각했던 점은 subscript의 return 값으로 ((Value) -&gt; Builder&lt;Base&gt;) 클로저 자체를 넘겼다는 점 입니다. 클로저를 return 할 수 있다는 것은 특별한 일이 아니지만, 클로저를 받은 쪽에서 함수로 사용할 수 있어서 결론적으로 text(\"hi\")와 같이 바로 실행할 수 있다는 것이 재밌다고 생각됩니다. 사용하는 쪽에서는 함수인지 클로저인지 고민할 필요없이 빌더의 set 함수라고 생각하고 작성할 수 있습니다. 잘 기억해뒀다가 나중에 응용하면 유용한 코드를 작성할 수 있을 것 같습니다." }, { "title": "리팩터링 1주차: 과제", "url": "/posts/RefactoringStudy1-2/", "categories": "", "tags": "", "date": "2021-04-11 11:49:00 +0000", "snippet": "리팩토링에 대해 어느정도는 들어본 내용이었지만 책을 읽어보니 좀 더 개념이 정리되는 것 같아서 뿌듯했습니다. 과제를 제출해야 환급되는 구조라서 열심히하게 되네요ㅋㅋ 분량을 채우기 위해 일부러 많이 작성한 부분도 있지만 기록을 위해 남겨둡니다.1. YAGNI에 대하여 서술하세요YAGNI는 “you aren’t going to need it”의 줄임말 입...", "content": "리팩토링에 대해 어느정도는 들어본 내용이었지만 책을 읽어보니 좀 더 개념이 정리되는 것 같아서 뿌듯했습니다. 과제를 제출해야 환급되는 구조라서 열심히하게 되네요ㅋㅋ 분량을 채우기 위해 일부러 많이 작성한 부분도 있지만 기록을 위해 남겨둡니다.1. YAGNI에 대하여 서술하세요YAGNI는 “you aren’t going to need it”의 줄임말 입니다. 미래에 추가될지도 모르는 스펙을 위해서 미리 추가적인 기능이나 인터페이스를 만들어 두지 말자는 취지의 말입니다. 이렇게 설계하는 방식을 간결한 설계, 점진적 설계라고 한다고 저자는 설명합니다. 현재 주어진 스펙 안에서 최대한 적절한 설계로 코드를 작성합니다. 실제로 추가적인 기능을 개발해야할 때 다시 리팩토링을 진행합니다. 미래에 추가될 스펙을 미리 예측해서 작업하는 것이 도움이 되는 경우도 있겠지만 오버엔지니어링으로 이득을 보는 경우는 많지 않습니다. 실제로 작업을 해보고 원하는 바를 정확하게 알게되었을 때 그것을 위해서 작업하는 것이 더 효율적입니다.현재 주어진 문제를 푸는것에 집중한다고 해서 설계를 대충하는 것은 아니라고 저자는 주의의 말을 합니다. 다만 아키텍처가 한번 작성되면 고정되는 것이 아니라 점진적으로 진화해 간다는 것을 기억하고 조금씩 발전시켜 나가는것이 중요합니다. 소프트웨어를 점진적으로 발전시켜 나가는데는 리팩토링이 가장 핵심이라고 할 수 있습니다.2. 리팩터링을 해야 할 때가 언제인지 저자의 견해를 서술하시요모든 경우에 리팩토링을 해야하는 것은 아닙니다. 저자는 구체적인 예시를 들며 리팩토링을 고려해야할 시점을 소개합니다. 3의 법칙: 비슷한 일을 3번째 하게되었을 때 준비를 위한 리팩토링: 조금만 리팩토링하면 기능을 추가하기 쉬울것 같을 때 이해를 위한 리팩토링: 이해한 바를 명시적으로 코드에 드러내고 싶을 때, 새로운 설계를 할 때, 새로운 코드를 접했을 때(새로운 팀에 갔을 때 조금씩 리팩토링 하면서 코드에 적응하는 것이 좋을 것 같다는 생각을 했습니다) 쓰레기 줍기 리팩토링: 간단히 수정할 수 있으면 바로 고치고, 아니라면 기록 후 나중에 리팩토링 수시로 하는 리팩토링: 저자가 지향하는 방향인데, 거창한 계획을 하는 것보다 프로그래밍 중에 최대한 자주 리팩토링을 하는 것을 추천함 조금씩 개선하기: 오래걸리는 리팩토링은 바람직 하지 못하다고 합니다.많은 부분을 재구조화 하면서 시간이 오래 걸린적이 있었는데, 이렇게 하면 리팩토링의 목적을 잊어버리게 되는 경우가 많았습니다.그런데 조금씩 개선을 하기 위해서는 유닛 테스트가 충분히 지원되어야 한다고 생각합니다. 리팩토링을 하지 말아야 할 때: 굳이 수정할 필요가 없을 때, 청므부터 새로 작성하는게 쉬울 때3. 설계 단계에서 모든 요구사항을 알 기 힘드므로 아키텍쳐의 변경이 필요할 때가 많다. 이를 해결하기 위한 저자의 견해를 서술하시오과거에는 모든 요구사항을 미리 파악하고 설계를 완벽하게 마친 후에 코드를 작성해야 한다는 생각이 널리 퍼져있었던 것 같습니다. 아마도 프로그래밍 활동을 건축하는 것과 비슷하게 바라보고 있었던 것 같습니다. 완벽하게 요구사항을 파악하는 것은 사실상 불가능 합니다. 그리고 애자일 방식이 널리 퍼지면서 프로그래밍 개발 주기 짧고 빨라졌기 때문에 요구사항도 계속해서 변한다고 볼 수 있습니다. 처음부터 모든 것을 파악하려고 하지말고 어느 정도 파악한 요구사항들을 설계에 녹여내면서 진행하는 것이 좋습니다. 개발하면서 요구사항이 더 명확해지는데 이때 리팩토링을 하면서 개선시켜 나갈 수 있습니다. 1번 질문에서 나왔던 YAGNI 개념과 동일한데 파악된 요구사항을 중점으로 개발합니다. 자신있는 리팩토링을 위해서는 테스트 코드가 있으면 훨씬 수월합니다. 테스트가 설계를 결정해주는 것은 아니지만 설계를 개선해나갈 수 있는 좋은 도구 입니다. 개인적인 경험으로도 겉보기 동작이 동일한 것을 확인해주는 테스트 코드가 있을 때 훨씬 더 자신있고 빠르게 설계를 개선할 수 있었습니다.4. 리팩터링으로 이점이 무엇인지 저자의 관점에서, 회사 윗사람을 설득시킨다는 생각으로 서술하세요리팩토링은 개발자들 사이에만 존재하는 윤리적인 문제가 아닙니다. 단순히 깔끔한 코드를 만들어내는 것이 전부가 아닙니다. 소프트웨어는 시간이 갈 수록 기능이 추가되는 경향이 있습니다. 기능이 추가될 수록 코드가 늘어나고 코드끼리 서로 영향을 줍니다. 그래서 시간이 지날 수록 개발 속도가 느려질 수 있습니다. 리팩토링을 하면 이해하기 쉽고 기능 추가를 하기 간편한 구조를 얻을 수 있습니다. 좋은 설계를 점진적으로 얻어갈 수 있다는 뜻인데, 이렇게 되면 개발 속도를 일정하게 유지할 수 있습니다. 이러한 경제적인 이유 때문에 리팩토링을 해야합니다.만약 개발 기간을 결정하는 사람을 설득할 수 없다면, 리팩토링을 한다는 말을 아에하지 않는 방법도 있습니다. 리팩토링은 대부분 기간을 따로 빼서 진행하는 것이 아니라 일상의 개발 중에 짧고 자주 진행되는 것들이기 때문에 특별한 기간 산정이 필요 없을 수도 있다고 합니다. 다만 누군가는 일부러 속이는 것은 아니라 리팩토링을 통해서 개발 속도를 높이고 최종적으로 회사의 매출에 더 기여할 수 있기 때문에 회사에도 좋을 일이 됩니다.5. 리팩터링이 어떻게 하여 소프트웨어의 성능에 도움이 될 수 있는지 저자의 관점을 서술하시오리팩토링을 진행할 때는 속도 보다 이해하기 쉬운 코드를 위주로 개선하게 됩니다. 이렇게 하면 약간의 속도 저하가 있을 수도 있습니다. 리팩토링 후에 코드를 파악해보면 속도를 저하시키는 부분을 찾는게 훨씬 더 쉽다고 저자는 말합니다. 복잡한 코드를 보면서 속도 저하가 있는 곳을 유추하는 것보다 리팩토링 후에 속도를 분석하는 것이 더 유용합니다.개발 중에 속도를 분석하면서 개발한다고 해도 속도를 높이는데 큰 도움이 되지 않았다고 합니다. 그리고 속도를 느리게 하는 부분은 프로그램의 10% 정도 밖에 되지 않는다고 합니다. 대부분의 경우 특별한 기능을 하고 있는 코드보다 당연하게 기존에 당연하게 작동하고 있는 부분이 속도를 느리게 하고 있습니다.리팩토리을 하게되면 이해하기 쉬운 코드를 얻게되고 버그를 찾을 확률도 높아집니다. 예를 들면 불필요하게 여러번 호출하고 있는 함수를 찾을 수 있습니다. 그래서 프로그래밍 속도를 높일 수 있다고 저자는 주장합니다. 특히 자주 읽게 되는 부분을 리팩토링하면 효과가 큽니다.6. 본인이 실제로 경험한 리팩터링에 대해 작성해 주세요10년된 코드를 품고 있는 프로그램을 개발 중이라서 리팩토링을 자주 하게 되었습니다. 처음에는 코드를 무작정 옮겨보기도 하고 완전히 새로 작성해보기도 했는데, 최종적인 결과물이 만족스럽지 않았습니다. 어떤 경우에는 리팩토링 후에도 기존의 설계와 거의 동일한 경우도 있었습니다. 리팩토링을 거창한 것으로 생각해서 많은 부분을 한꺼번에 수정하려고 해서 설계를 빠르게 변화시키지 못했던 것 같습니다. 너무 완벽한 결과물을 얻으려는 마음보다 일상에서 작은 부분을 자주 개선시켜야 겠다는 생각을 했습니다." }, { "title": "리팩터링 1주차: 챕터 2 요약", "url": "/posts/RefactoringStudy1/", "categories": "", "tags": "", "date": "2021-04-05 10:19:00 +0000", "snippet": "패스트캠퍼스 리팩터링 완독반을 신청해서 스터디를 시작했습니다. 환급반이라서 책을 읽어야 돈을 잃지 않는 구조 입니다. 공부할 것들이 너무 많아서 스터디를 미루기 쉬운데, 이렇게 해서라도 동기부여를 할 수 있을 것 같아서 신청했습니다.스터디 설명리팩터링 2판 자바스크립트로 예시가 되어 있음 리팩터링 패러다임은 언어를 초월하여 의미가 있음 그러나 실...", "content": "패스트캠퍼스 리팩터링 완독반을 신청해서 스터디를 시작했습니다. 환급반이라서 책을 읽어야 돈을 잃지 않는 구조 입니다. 공부할 것들이 너무 많아서 스터디를 미루기 쉬운데, 이렇게 해서라도 동기부여를 할 수 있을 것 같아서 신청했습니다.스터디 설명리팩터링 2판 자바스크립트로 예시가 되어 있음 리팩터링 패러다임은 언어를 초월하여 의미가 있음 그러나 실제 활용은 언어에 귀속됨배워서 어디에 써먹을까? 리팩터링이 필요한 이유를 설득할 수 있음 책 한권 읽는다고 설득할 수 있는 것은 아님 적어도 물꼬는 틔워줄 수 있음 리팩터링 중 발생하는 고민을 일정량 줄일 수 있다. 간결한 코드가 좋을까, 성능이 우월한 방법이 좋을까? 어느정도의 성능 감소를 용인할 수 있을까? 깔끔한 코드와 디버깅이 용이한 코드 중 무엇을 할까? 언제 리팩터링 할까? 냄새나는 코드 냄새가 얼마나 나야 리팩터링 해야하나? 훨씬 깔끔한 코드를 작성할 수 있음 리팩터링을 수정하는 것이지만, 창조할때도 유용 동료의 Code Review 할 때 동료와 팀의 생산성에 기여할 수 있다! 스터디에서 다루는 범위 챕터 1 생략 매주 가이드 영상에서 책의 내용을 요약해줌 이렇게 스터디 해본적은 없는데, 내용 요약에 대한 부담이 줄어서 오히려 의문이 드는 부분만 핵심적으로 파볼 수 있을 것 같다.챕터 2: 리팩터링 원칙리팩터링 정의 Why: 코드 이해와 수정이 쉽도록 What: 내부 구조 변경 How: 겉보기 동작은 유지겉보기 동작 유지 콜스택이나 인터페이스가 달라지는 것은 변화가 아님 같은 함수인데 지역변수를 함수의 파라미터로 놓기 어디까지나 겉보기 동작에는 변화가 없음 그런 어디부터 변화? (추상적 기준) 버그도 그대로 남아 있어야 한다 만약 리팩터링 하는 과정에 사소한 버그가 발견되면 수정해도 상관없음 하지만 이미 알고 있는 버그이고, 수정할 계획이 있었다면 리팩터링 중에는 수정하지 않기 이 책에서 정의한 리팩터링은 굉장히 좁다 누군가 리팩털이 하다가 코드가 꺠져서 며칠이나 고생했다 라고 한다면, 십중팔구 리팩터링 한것이 아니다 (80페이지) 이건 어떤 의도로 한 말일까?두개의 모자 기능추가 / 리팩터링 하나의 모자를 쓸 때는 하나의 변화만 리팩터링 할 때는 버그도 그대로 둬야함리팩터링 하는 이유 소프트웨어 설계가 좋아진다 소프트웨어를 이해하기 좋아진다 버그를 쉽게 찾을 수 있다 프로그래밍 속도를 높일 수 있다: 이게 가장 핵심적인 이유언제 리팩터링해야 할까? 3의 법칙 (3진아웃 리팩터링) 비슷한 일을 3번째 하게되면 리팩터링한다 준비를 위한 리팩터링 기능을 쉽게 추가하게 만들기 리팩터링을 조금만 하면 기능 추가하기 쉬울것 같을 때 “잠깐, 지도를 찾아보고 가장 빠른 경로를 찾아보자” 이해를 위한 리팩터링 코드를 이해하기 쉽게 만들기 이해한 바를 명시적으로 코드에 드러내도록 수정할 수 있음 새로운 설계에 도움 동료간 교류에 도움 새로운 코드를 접했을 때 리팩토링을 하는 것이 코드 이해에 도움이 될 수 도 있겠다 쓰레기 줍기 리팩토링 코드가 일을 비효율적으로 처리하는것을 발견했을 때 간단히 수정할 수 있으면 바로 고친다 아니라면 기록 후, 하던일을 마치고 처리한다 이슈 작성해서 큐에 넣어두기 계획된 리팩터링과 수시로 하는 리팩터링 프로그래밍 중 상시 지속되는 활동: 저자가 지향하는 것 소홀했던 부분을 작성하고 리팩터링하는 것도 필요 무조건 나쁜 것은 아님 오래 걸리는 리팩터링 리팩터링은 대부분 몇 분 안에 끝난다. 길이야 몇 시간 정도다 조금씩 개선 코드 리뷰에 리팩터링 활용하기 팀원의 코드 리뷰를 할 때 리팩터링 기법을 이용 관리자에겐 뭐라고 말해야 할까? “어설픈 재구성”은 리팩터링이 아니다 “설계 지구력 가설”: 추진력을 얻기위해 무릎을 꿇는 과정을 관리자에게 어필 아니면 아예 리팩터링 한다고 말하지 말아라 리팩터링은 어차피 프로그래밍의 일부 리팩터링 하지 말아야 할 때 굳이 수정할 필요가 없을 때 코드가 지저분한데 한 함수안이 지저분하다… 블랙박스로 되어 있고 성능이 잘나오고 있다면 굳이 수정할 필요 없음 처음부터 새로 작성하는게 쉬울 때 리팩터링 시 고려할 문제 새 기능 개발 속도 저하된다는 오해 이후에 개발 속도를 빠르게 하기 위함 팀원들을 설득하고 훈련시키는 것이 중요함 리팩터링은 ‘클린코드’, ‘바람직한 엔지니어링 습관’ 같은 도덕적인 것이 아님 오로지 경제적인 이유로 하는 것 코드 소유권 구현코드와 호출코드의 소유자가 다른 팀일 때, 공개 API를 사용할 때 등 여전히 리팩터링 가능하다. 제약이 따를 뿐 코드 소유권을 세부적으로 나눠서 관리하는 것을 바람직하지 않다고 함. 아마존에서도 소스코드를 팀별로 관리하고 있다고 함 오픈소스 개발 모델 차용 브랜치 메인 브랜치 -&gt; A / B / C 브랜치 나눠서 작업 -&gt; 나중에 머지 이 처럼 독립브랜치로 일할 때 통합되는 기간이 길어질 수록 통합이 어려워짐 브랜치 통합주기를 2~3일, 그 보다 더 짧게 최소 하루에 한번 통합 단, 완료되지 않은 기능이 시스템 전체를 망치지 않도록 주의 리팩터링이 일어나면 코드 전반에 소규모 수정이 일어남 -&gt; 머지 중에 충돌이 발생할 가능성이 높음 테스팅 리팩터링은 동작 변화가 없어야 한다 테스트 자체가 하나의 기준이 될 수 있음 의도치 않은 버그를 빠르게 잡을 수 있음 버그 생길 위험이 크다는 불안감 해소 가능 레거시 코드 한계를 언급함 대부분의 코드베이스는 다른사람이 작성한 것 테스트 없이 리팩터링은 어렵다 -&gt; 테스트를 보강하라! 쉽게 해결할 방법은 없다 데이터베이스 안 되는 줄 알았느데 가능하더라 리팩터링, 아키텍처, 애그니(YAGNI) 기존 패러다임 요구사항 사전에 완벽 파악 -&gt; 코딩전에 아키텍처 확정 사실상 불가능 요구사항이 계속 변함 유연성 메커니즘을 심어두는 방안 미래를 대비해서 기능을 미리 만들어두는 것 코드를 너무 유연하게 하면 오히려 대응 능력을 떨어트림… YAGNI(You aren’t going to need it: 아마 필요 없을 거다) 현재까지 파악한 요구사항만 해결 해당 요구사항을 멋지게 해결 진행중 요구사항을 파악하면 그때그떄 리팩터링하여 수정 요구사항을 이해했을 때 처리하는게 훨씬 더 낫다 리팩터링과 소프트웨어 개발 프로세스 XP TDD 애자일 소프트웨어 테스트 코드, 지속적 통합리팩터링과 성능 하드웨어가 발전하기 때문에 성능은 상관없음이 아님 리팩터링을 하고나면 성능을 튜닝하기 쉬워진다 결과적으로는 성능에도 도움이 됨성능 중심 개발방법 시간예산분배: 제한된 조건에서만 사용됨 끊임없이 관심 기울이기: 모든 코드를 쓸 때 성능향상에 초점 실제 효과가 변변치는 않음 90%시간은 낭비 대부분의 프로그램은 극히 일부분에서 대부분의 시간을 소모한다 아무것도 안 만드는데도 시간이 걸린다 ex) 알고보니 하나의 함수를 쓸데없이 여러번 호출 성능상 문제가 되는 부분은 10%밖에 안된다 그 부분을 찾기 쉽게하려면 리팩터링 프로파일러로 분석하여 해당 부분만 성능 개선 크게 느려지지 않은 나머지 90%의 성능개선에 투자하는것은 낭비기타 리팩터링의 유래 저자가 리팩터링 개념을 창시하게 된 과정" }, { "title": "RIBs 스터디 2: 공식 레포 Wiki", "url": "/posts/RIBsStudy2/", "categories": "", "tags": "", "date": "2021-04-02 15:00:00 +0000", "snippet": "이번에는 RIBs/wiki 보면서 RIBs에 대해 배워보겠습니다.RIBs 개념 정리 RIBs는 크로스 플랫폼 아키텍처 프레임워크 프레임워크는 정해진 틀에 코드를 넣으면 시스템이 약속된 기능을 작동시켜주는건데, 이 개념에 맞는지는 좀 더 살펴봐야겠습니다. RIB을 작성하는 템플릿이 있지만 프로그래머가 직접 관계를 지정해줘야하는...", "content": "이번에는 RIBs/wiki 보면서 RIBs에 대해 배워보겠습니다.RIBs 개념 정리 RIBs는 크로스 플랫폼 아키텍처 프레임워크 프레임워크는 정해진 틀에 코드를 넣으면 시스템이 약속된 기능을 작동시켜주는건데, 이 개념에 맞는지는 좀 더 살펴봐야겠습니다. RIB을 작성하는 템플릿이 있지만 프로그래머가 직접 관계를 지정해줘야하는 면에서 라이브러리라고 볼 수 있는건 아닐까? 하는 생각은 들었습니다. 우버를 위해 이 프레임워크를 디자인 했을때, 다음 원칙을 고수함: 크로스 플랫폼 협력을 독려함 iOS와 Android 앱에서 대부분의 복잡한 부분은 비슷함 RIB는 iOS와 Android에 비슷한 개발 패턴을 제공함 의문점 아키텍처가 통일된다고 해서 서로의 코드를 공유하는 일이 있을까? 하는 의문이 들기는 합니다. 아키텍처가 달라서 문제가 되는 부분이 있을지 의문도 들었습니다. 모바일 팀 매니저 입장에서는 관리하기 편하겠다는 생각도 듭니다. 여러 플랫폼에서 동일한 아키텍처를 적용하는 시도를 아직 못해봤는데, 일단 한번 경험해보고 싶다는 생각이 들었습니다. 전역 상태와 결정을 최소화 전역 상태를 변경하시는 것은 예측하지 못한 행동을 불러일으킬 수 있음 계층화된 RIB들에 상태값을 캡슐화 하도록 함 테스트 및 격리 클래스는 유닛 테스트 하기 쉬워야 함 클랫스는 독립적으로 추론 가능해야 함 독립된 RIB는 고유한 책임을 가짐 부모 RIB 로직은 하위 RIB 로직으로 부터 대부분 분리됨 대부분? 예외로 안되는 경우도 있나보다 개발자 생산성을 위한 도구 제공 코드 생성 정적 분석 런타임 통합 이건 뭐지? 개방 폐쇄 원칙 개발자가 기존 코드 수정 없이 새로운 기능을 추가할 수 있어야 한다 부모 RIB에 의존성이 필요한 child RIB을 코드 변경 없이 attach 또는 build 할 수 있다 비즈니스 로직을 중심으로 구조화 비즈니스 로직이 UI 구조를 반영할 필요는 없음 애니메이션 &amp; View 퍼포먼스를 높이기 위해서 View 구조는 RIB 구조보다 얕은 계층 구조로 만들 수 있음 또는 하나의 RIB이 다른 여러 UI를 컨트롤 할 수 도 있음 의문점 View에 비즈니스 로직을 가두는 구조가 아닌건 흥미로움 그러나 이런 케이스가 얼마나 있을까 하는 의구심도 생김 구체적인 예를 볼 수 있으면 좋겠습니다. 명시적 계약(Contracts) 요구사항들은 컴파일 타임 계약으로 명시되어야 함 클래스와 순서에 대한 의존성이 만족되지 않으면 클래스는 컴파일 되지 않아야 함 순서에 대한 의존성은 무엇일까? Ordering dependencies 순서 의존성(ordering dependency)을 표현하기 위해 ReactiveX를 사용함 이 부분 무슨말인지 하나도 모르겠음… 나중에 다시 읽어볼 것 We use ReactiveX to represent ordering dependencies, type safe dependency injection (DI) systems to represent class dependencies and many DI scopes to encourage the creation of data invariants. RIB 구성 요소VIPER 아키텍처를 사용하고 있었다면 RIB의 클래스들이 익숙할 것임Interactor 비즈니스 로직이 담겨짐 Rx subscription을 수행하는 곳 이건 뭔지 잘 모르겠음 상태 변경을 결정함 어떤 데이터를 어디에 저장할지 결정함 어떤 child RIB이 attach 되어야할지 결정함Router Router는 Interactor의 Output을 듣고 자식 RIB을 attach 또는 detach 하는 것으로 변환 시켜줌 아래 3가지 이유로 존재함 Router는 Humble Object로 기능한다. Child interactor를 mock 하거나 신경쓰지 않고서, 복잡한 Interactor 로직을 테스트하기 편하게 하기 위한 역할. Humble Object는 무엇일까?- [https://martinfowler.com/bliki/HumbleObject.html](https://martinfowler.com/bliki/HumbleObject.html)- 테스트하기 어려운 객체를 만남 -&gt; 로직을 테스트 가능한 코드로 이동시킴, 원래 객체는 `humble` 해짐- ![humble object](/assets/2021/04/humble-object.png) Router는 부모와 자식 Interactor간에 추가적인 추상 레이어를 만듦. 인터렉터 간 synchronous communication을 어렵게 만든다 직접 결합 대신 reactive communication을 채택하도록 장려함 무슨말인지 모르겠다… 실습 해봐야 체감할 수 있을 듯 Router는 단순하고 반복적인 라우팅 로직을 포함함 그렇지 않았으면 Interactor에 구현되어야 하는 부분 boilerplate code를 facotring out 하면 Interactor를 작게 유지하고 핵심 비즈니스 로직에 집중할 수 있음 BuilderBuilder은 RIB의 구성 클래스들을 생성하는 역할. 하위 RIB들의 builder도 생성해줌. 클래스 생성 로직을 분리하는 것 iOS에서의 mockability를 향상 시킴 나머지 RIB 코드를 DI 구현의 세부사항과 무관하게 만듦 DI 시스템을 인식해야하는 RIB의 유일한 부분 다른 DI 매커니즘을 통해서 기존의 RIB 코드를 재사용 가능하다Presenter Presenter는 stateless 클래스. Business model을 View model로 변형시켜줌 (반대로도 가능) 반대로도 가능한게 좀 신선한데… 그런일이 있을까? 나중에 확인해봐야겠다 뷰모델 변환 테스트를 가능하게 함 하지만 이러한 변환은 너무 사소한 것이라서 Presenter 클래스가 필요없는 경우가 많음 Presenter가 생략되면 view model로 변환하는 작업은 View(Controller) 또는 Interactor의 책임이 됩니다View(Controller) View들은 UI를 빌드하고 업데이트 함 UI 컴포넌트들을 생성하고 레이아웃, 유저 인터렉션 핸들링, 데이터로 UI 컴포넌트 채우기, 애니메이션을 포함함 가능한 기능이 없어야 함 (Views are designed to be as “dumb” as possible.) 정보를 보여주기만 해야 함 일반적으로, 유닛 테스트가 필요한 코드는 여기에 포함되지 않습니다Component RIB dependencies를 관리하기 위해 사용됨 RIB을 구성하는 다른 unit들을 생성해서 Builder들을 도와줌 Components는 외부 의존성들에 접근할 수 있도록 해줌 RIB 자체에서 생성된 종속성을 소유함 다른 RIB으로 부터 해당 종속성에 대한 접근을 제어함 보통 부모 RIB의 Component는 child RIB의 Builder로 주입된다. 자식 RIB에게 부모 RIB의 종속성에 접근할 수 있도록 하기 위해서State Management 어플리케이션 상태는 현재 RIB 트리에 attach된 RIB으로 표시됨 예를들어, 차량 공유 앱에서 여러 생태를 거치면서, 앱은 다음과 같이 RIBs를 attach하고 detach 한다 RIBs는 그들의 scope 안에서만 상태를 결정한다. 예를들어, LoggedIn RIB은 Request와 OnTrip 같은 전환에만 상태 결정을 한다.일부 State는 RIB 추가/제거를 통해 보관하지 않음 예를들어, 유저 프로필의 세팅을 변경할 때, 어떤 RIB도 attach 되거나 detach 되지 않음 일반적으로 불변 모델의 스트림 내부에 이 상태를 저장함. 정보가 변경될 때 값을 재방출함(re-emit). 예를들어, 사용자 이름은 LoggedIn scope 안의 ProfileDataStream에 저장될 수 있음 네트워크 Response만 이 스트림에 대한 write 권한을 가짐 이러한 스트림들에 대한 read 접근에 인터페이스를 DI 그래프로 전달함RIB state를 위해 single source of truth를 강제하지 않음 React 같은 프레임워크와는 대조적 각 RIB의 컨텍스트 내에서 단반향 데이터 플로우 패턴을 선택하거나 효율적인 애니메이션을 위해 비즈니스 상태와 view 상태가 일시적으로 다른것을 허용해줄 수 있음Communication Between RIBs Interactor가 비즈니스 로직을 결정할 때, 다른 RIB에 알려줘야 할 때도 있다.(event, completion, send data…) RIB 프레임워크는 RIB 간에 데이터를 전달하는 single way를 포함하지 않음 그럼에도 불구하고, 몇 가지 일반적인 패턴을 가능하게 만들어짐 만약 커뮤니케이션이 parent RIB의 Interactor로 올라가면, 커뮤니케이션은 listener 인터페이스를 통해 이루어진다. parent가 child보다 오래 존재할 수 있기 때문 이것도 이해 못했음 parent RIB 또는 그것의 DI 그래프 안의 object는 listener 인터페이스를 구현한다. 그리고 listener 인터페이스를 그것의 DI 그래프에 위치 시킨다. children RIB이 호출할 수 있도록! parent가 children의 Rx stream을 직접 subscribe 하지 않고, 데이터를 위로 전달하는이 이 패턴을 통해 얻는 이점 memroy leak 방지 어떤 children이 attach 되었는지 모르고 작성, 테스트, 유지할 수 있음 child RIB을 attach/detach 할 때 생각해야하는 양을 줄여줌 child RIB을 이러한 방식으로 attach 하면, Rx stream을 unregistered/re-registered 할 필요가 없음 다음 공부할 거리 튜토리얼 따라하기: https://github.com/uber/RIBs/wiki/iOS-Tutorial-1 의문이 생긴 부분들 튜토리얼 후에 다시 생각해보기" }, { "title": "RIBs 스터디 1: Let'Swift 발표들로 RIBs 맛보기", "url": "/posts/RIBsStudy/", "categories": "", "tags": "", "date": "2021-03-31 14:38:00 +0000", "snippet": "많은 팀에서 도입하고 있는 RIBs 아키텍처에 대해 스터디 해보겠습니다. RIBs 레포의 설명도 좋지만, 먼저 안정민님이 정리해주신 자료들로 필기해보며 공부를 시작해보겠습니다.MVC, MVVM, ReactorKit, Viper를 거쳐 RIB 정착기 (1)https://www.youtube.com/watch?v=3XS6xLzKRjc 강의 필기 입니다.기...", "content": "많은 팀에서 도입하고 있는 RIBs 아키텍처에 대해 스터디 해보겠습니다. RIBs 레포의 설명도 좋지만, 먼저 안정민님이 정리해주신 자료들로 필기해보며 공부를 시작해보겠습니다.MVC, MVVM, ReactorKit, Viper를 거쳐 RIB 정착기 (1)https://www.youtube.com/watch?v=3XS6xLzKRjc 강의 필기 입니다.기존 아키텍처에 왜 만족 못했는가? 화면 단위가 아닌 프로세스 단위로 유연한 개발 필요 자체 제작 아키텍처의 유지 보수 어려움 더 확실한 안정화 필요 테스트 코드 템플릿 또는 가이드가 있는 아키텍처가 거의 없음 체계화된 테스트 코드 작성이 필요 아키텍처 여정MV(C) 장점: 기존에 익숙한 구조. 단순환 화면에만 적용 단점: 기능이 확장되면 깔끔하지 않아짐MVVM 장점: MVC보다는 코드가 정리되는 느낌 단점: 기능이 복잡해질수록 ViewModel이 빠르게 비대해짐. 표준화된 틀이 존재하지 않음. 이해가 다름. 테스트 코드 작성이 가능하지만 어려움. Rx 허들 및 디버깅…ReactorKit 장점: 단방향이라 View와 관계된 로직이 깔끔 단점: 프로세스 단위의 아키텍처라 아니라서 아쉬움.VIPER 장점: VIPER 역할이 명확하게 구분됨 단점: 명확한 가이드, 테스트 코드 템플릿이 정형화되어 있지 않음RIBs 선택한 이유 RIBs에 대한 설명은 https://www.youtube.com/watch?v=BvPW-cd8mpw 이것을 보는게 좀 더 좋다고 해서 좀 더 아래쪽에 따로 정리해뒀습니다. 템플릿화된 코드 및 테스트 작성 https://github.com/uber/RIBs/tree/master/ios/tooling 템플릿을 통해 RIB / RIB Unit Tests / Component extension 을 만들 수 있습니다. (Component extension 이건 뭔지 모르곘네요… 나중에 찾아보겠습니다) Owns corresponding View: View가 있는 RIB을 만들건지 선택Adds Storyboard file: View를 Storyboard로 만들지, 아니면 xib로 만들지 선택가능 체크한 항목에 따라 아래와 같이 파일을 만들어 줌 템플릿으로 테스트 코드도 구성 가능. 테스트 코드에 Mock 구성하는 방법도 있음. Tutorial2/TicTacToeTests/TicTacToeMocks.swift present가 호출되었는지, 클로저가 호출되었는지 확인하는 가이드를 제공해주고 있음. 이 코드는 템플릿으로 제공해주지는 않고 있음. SourceKitten을 이용해서 Mock 코드 생성하는 스크립트 이용중 프로토콜 지향 프로그래밍 프로토콜이 굉장히 많이 사용되는데… 아직 익숙하지 않아서 그런지 헷갈리네요;;Interactorimport RIBsimport RxSwift // Rx는 필수일까?// 이 코드가 Interactor 쪽에 있어야 함protocol LoggedInRouting: ViewableRouting { // 여기에 원하는 명령을 추가 // -&gt; Router는 컴파일 에러 // -&gt; Router에 가서 컴파일 에러 수정}protocol LoggedInPresentable: Presentable { var listener: LoggedInPresentableListner { get set }}// 상위 RIB이 어떤 Interaction에 대해 호출을 해야 할 때// \"나는 내 작업이 끝났어\" 하고 알려줘야 할 때protocol LoggedInListener: class {}final class LoggedInInteractor: PresentableInteractor&lt;LoggedInPresentable&gt;, LoggedInInteractable, LoggedInPresentableListner { // Interactor는 Routing 과 View를 알고 있어야하기 때문에 weak 변수로 가지고 있음 weak var router: LoggedInRouting? weak var listener: LoggedInListener? ovrride init(presenter: LoggedInPresentable) { super.init(presenter: presenter) presenter.listner = self } ovrride func didBecomeActive() { super.didBecomeActive() // TODO: Implement business logic here. } ovrride func willResignActive() { super.willResignActive() // TODO: Pause any business logic. // 여기에 Routing 작업을 할 수 있음 }}Routerimport RIBsprotocol LoggedInInteractable: Interactable { var router: LoggedInRouting? { get set } var listener: LoggedInListener? { get set }}// View에 어떤 Present를 할지, Push를 할지 방향을 정하는 역할protocol LoggedInViewControllable: ViewControllable {}final class LoggedInRouter: ViewableRouter&lt;LoggedInInteractable, LoggedInViewControllable&gt;, LoggedInRouting { override init(interactor: LoggedInInteractable, viewController: LoggedInViewControllable) { super.init(interactor: interactor, viewController: viewController) interactor.router = self }}Viewimport RIBsimport RxSwiftimport UIKit// View에서 Action이 일어났을 때 -&gt; Interactor 쪽에다 알려줘야 하는 것을 정의// Interactor는 이 프로토콜을 구현해야 함// 한 군데라도 프로토콜을 따르지 않았다면 컴파일 에러가 발생해서 -&gt; 에러가 나는 곳을 구현해주면 됨protocol LoggedInPresentableListener: class {}final class LoggedInViewController: UIViewController, LoggedInPresentable, LoggedInViewControllable { weak var listener: LoggedInPresentableListner?}부모 RIB &lt;-&gt; 자식 RIB 간의 통신Interactor를 통해서만 통신을 하게 되어 있음복잡한 로직도 Interactor간의 통신으로만 구현 가능함의존성 주입 DI해당 RIB에서 필요한 속성을 Dependency에 정의import RIBs// 해당 RIB은 여기에 있는 정보를 사용할 수 있음protocol LoggedInDependency: Dependency {}final class LoggedInComponent: Component&lt;LoggedInDependency&gt; {}이런식으로 만들 수 있음import RIBsprotocol LoggedInDependency: Dependency { var name: String { get } var nickName: String { get }}final class LoggedInComponent: Component&lt;LoggedInDependency&gt; { fileprivate var name: String { return dependency.name } fileprivate var nickName: String { return dependency.nickName }} dependency가 확장되면 컴파일 에러 발생 해당 RIB을 사용하는 곳은 다 작성을 해야 함RxRIBs, Multiplatform architecture with Rxhttps://www.youtube.com/watch?v=BvPW-cd8mpw회사 세미나에도 발표하러 오셨었는데 들었던 이후로 시간이 꽤 지나서 다시 들으며 정리했습니다.새로운 아키텍처 필요했던 이유 서비스를 빨리 출시해서 운영 노하우를 얻고자 했음 기존 방식으로 업무를 진행하면 안되겠다고 생각함 두 플랫폼에서 동일한 아키텍처를 사용하고 싶었음고민 요소 MVC는 최대한 피하자 Single Activity Application 안드로이드의 Activity 생성, 관리가 까다로움 타다 같은 경우는 map-based 로 만들려고 했음 프레임워크를 처음부터 끝까지 만들 시간이 없었음RIBs https://github.com/uber/RIBs Router, Interactor, Builder, (Presenter, View)Interactor RIB에서 비즈니스 로직을 담당함 API를 어떻게 호출할지, 데이터를 어떻게 저장할지, 어떤 State로 바꿔줄지 Interactor에서 이루어짐Router 여러 RIB이 존재할텐데 A RIB -&gt; B RIB으로 바꾸는 과정을 라우터가 신경써야 함 트리상에서 어떻게 립이 존재할지, 트랜지션이 어떻게 일어날지 결정 다른 Interactor를 호출하는것을 봉쇄시킴Builder 팩토리 패턴으로 RIB의 컴포넌트들을 생성해주는 역할을 함 클래스들의 Mockability가 향상됨 &lt;- 요건 무슨말이지…? Builder는 실제 DI 시스템이 어떻게 구현되어 있는지 알고있는 유일한 클래스View UI 컴포넌트들을 Layout 하고 애니메이션만 존재하도록Presenter View 로직이 필요할 떄만 추가함State 관리Convoluted state machines State 관리에 장점이 있음 앱에는 많은 State가 있음…State tree 어떠한 형태든 Tree 형태로 상태를 그릴 수 있게 되었음 이게 모든 앱이 다 가능할까??? 타다는 우버와 비슷한 목적의 앱이라서 잘 사용할 수 있었던건 아닐까? 나중에 예제 따라해보면서 고민해보기 비즈니스 로직에 따라 상태를 변경함. 경우에 따라 여러 RIB이 attach된 경우도 있음 뷰 로직에 따라 상태를 변경하지 않았음!!Scope State tree를 사용했을 때 장점은 Scope를 한정 시키는 것협업하기 좋아짐 관심사 분리 레고 블럭 쌓듯이 구현해서 조립함어려움Flow of Data우버에서 사용하는 방식은 양방향 데이터 플로우VCNC에서는 단방향 데이터 플로우로 변경해서 사용함Animations UITransitionDelegate를 이용함 HeroTransition 이라는 라이브러리를 사용하고 싶었음 RIB 간의 transition에서는 위의 두 방식을 사용하게 헀음 그래서 RIB lifecycle을 변경해서 사용함요약배운점 지난번에 한번 시도했다가 프로토콜들이 너무 많아서 힘들었던 기억이 있습니다. 하지만 각 역할을 좀 더 명확하게 하고 프로토콜이 변경되었을 때 컴파일 에러를 발생시키는게 변경을 더 명확하게 알아차리게 하는 장점이 될 수 있음을 알게되었습니다. 안정민님이 사용한 예시가 RIBs tutorial에 있는 것들인데 이것부터 따라해보면 좋겠다는 생각을 했습니다. 테스트 코드에 대한 템플릿도 있는게 굉장히 좋다고 생각합니다. 테스트 작성에 손이 잘 안가는 문제가 있는데, 이렇게 하면 테스트 코드로 가는 허들을 조금 더 낮출 수 있을 것 같습니다. iOS &amp; 안드로이드 플랫폼 둘 다 RIB를 썼을 때 장점이 과연 어떨지 직접 경험해보고 싶다는 생각도 들었습니다. 어차피 Swift / Kotlin으로 각각 나눠서 작업 하는거면 내부의 아키텍처가 동일하더라도 각각 작업하는건 똑같을 것 같은데… 과연 이게 그렇게 큰 장점일지 궁금해졌습니다. 아니면 한 사람이 두 코드 베이스를 유지보수 할 수 있는 뜻인가…? 버그를 수정할 때 아키텍처 이슈보다 UI 오류였던 적이 더 많은 것 같아서 드는 고민입니다." }, { "title": "Github Action으로 iOS 프로젝트 테스트하기", "url": "/posts/Github-Actions-Swift-Test/", "categories": "", "tags": "", "date": "2021-03-30 14:18:00 +0000", "snippet": "회사 Github이 드디어 Github Action이 가능한 버전으로 업데이트 되었습니다. 개인 프로젝트에서 미리 테스트를 해보려고 합니다. Github Action이 생긴지 꽤 시간이 지나서 많은 분들이 튜토리얼을 남겨두었습니다. 하지만 직접 기록을 남기면서 배우는게 있을 것으로 생각하고 글을 작성합니다.Github 레포로 가면 Actions라는 탭...", "content": "회사 Github이 드디어 Github Action이 가능한 버전으로 업데이트 되었습니다. 개인 프로젝트에서 미리 테스트를 해보려고 합니다. Github Action이 생긴지 꽤 시간이 지나서 많은 분들이 튜토리얼을 남겨두었습니다. 하지만 직접 기록을 남기면서 배우는게 있을 것으로 생각하고 글을 작성합니다.Github 레포로 가면 Actions라는 탭이 있습니다.아마도 Swift로 작성된 코드가 있어서 센스있게 Swift를 추천하고 있는 것 같습니다. 무튼 Set up this workflow를 눌러봅니다.그러면 workflow 명세를 작성할 수 있는 화면이 나옵니다.문법을 어디서 찾아야하는지 몰라서 헤맸는데, 오른편에 두번째 탭에 보면 Documentation이라고 있습니다. 여기에 커스터마이징 하는 방법에 대해 자세히 나와있습니다.실행 조건 걸기main과 release/* 브랜치에 push 왔을 때 workflow 실행하기on: push: branches: - main - release/*main 브랜치에 PR 왔을 때 workflow 실행하기on: pull_request: branches: - main시간 정해놓고 반복적으로 workflow 실행하기on: schedule: - cron: \"0 2 * * 1-5\"근데 저 간이 document에는 모든 브랜치에 다 적용하는 가이드는 없었습니다… 그래서 좀 찾아보니, 이런식으로 적용하면 된다고 합니다. detail documenton: push: branches: - '*' # matches every branch that doesn't contain a '/' - '*/*' # matches every branch containing a single '/' - '**' # matches every branch - '!master' # excludes masterhttps://stackoverflow.com/a/57903434on: push: branches-ignore: # !master 이런식으로 표현하는대신 branches-ignore에 담아도 되네요 - master동작 지정jobs: test: name: Test on node $ and $ runs-on: $ strategy: matrix: node_version: ['8', '10', '12'] os: [ubuntu-latest, windows-latest, macOS-latest] # 이렇게 여러개의 OS에서 실행해 볼 수 있습니다 steps: - uses: actions/checkout@v1 - name: Use Node.js $ uses: actions/setup-node@v1 with: node-version: $ - name: npm install, build and test run: | npm install npm run build --if-present npm testSwift를 선택하고 만들어지는 샘플은 이렇게 되어 있습니다.jobs: build: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Build run: swift build -v - name: Run tests run: swift test -v일단 이대로 저장해보겠습니다. yml 파일을 레포에 저장하는 식으로 되어 있습니다.일단 실행시켜보기지금 main 브랜치에 push 될 때면 위의 동작을 실행하는걸로 되어 있는데요. push를 한번 해보겠습니다… 라고 하려했는데ㅋㅋ오잉 그 전에 Actions 탭 &gt; Build 를 눌러보면 트리거 없이 바로 실행 시켜볼 수 있습니다. git을 더럽히지 않아도 빌드는 테스트 해볼 수 있겠네요네 빌드 실패했습니다.error: root manifest not found 요 내용을 보니까 Swift Package로 인식하고 빌드한 것 같은데… 빌드 옵션을 구체적으로 지정해줄 필요가 있을 것 같습니다. 이번엔 이렇게 바꾸고 실행해보겠습니다.steps:- uses: actions/checkout@v2- name: Run tests run: swift build -v xcodebuild test -project Algo.xcodeproj -scheme Algo -destination 'platform=iOS Simulator,name=iPhone 11 Pro,OS=13.6'아니… 안되네요ㅠㅜ 이제보니 swift build -v 부분을 뺴야 합니다ㅋㅋ… 아 그리고 프로젝트 최소 설정이 iOS 14.4로 되어 있어서 OS 버전도 변경했습니다.- name: Run tests run: | xcodebuild test -project Algo.xcodeproj -scheme Algo -destination 'platform=iOS Simulator,name=iPhone 11 Pro,OS=14.4'드뎌 성공…!!!일부러 테스트 케이스 하나를 실패하도록 만들고 push를 해보겠습니다.그러면 의도했던대로 테스트 케이스가 실패하는걸 확인해줍니다.실험해보고 나서 다시 revert 해줬습니다ㅋㅋ다음에 좀 더 확인할 부분예제로 사용한 프로젝트는 Swift Package Manager로 라이브러리들을 구성해뒀기 때문에 별 문제 없이 빌드가 된 것 같습니다.빌드 앞부분을 보면 별다른 세팅을 안해줬는데도 라이브러리들을 연결해주는 것을 볼 수 있습니다.Resolved source packages: Nimble: https://github.com/Quick/Nimble @ 9.0.0 CwlPreconditionTesting: https://github.com/mattgallagher/CwlPreconditionTesting.git @ 2.0.0 CwlCatchException: https://github.com/mattgallagher/CwlCatchException.git @ 2.0.0 Quick: https://github.com/Quick/Quick @ 3.1.2제가 사용하고 싶은 환경은 코코아팟, 카르타고 둘 다 있는 환경이기 때문에 좀 더 가혹한 환경을 만들어두고 한번 더 실험해봐야할 것 같습니다.참고 https://macgongmon.club/24 https://zeddios.tistory.com/825 https://leenarts.net/2020/02/12/github-actions-for-ios-projects/ https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" }, { "title": "Let'Swift 후기: 개발자와 사용자 모두를 위한 접근성", "url": "/posts/Let'Swift/", "categories": "", "tags": "", "date": "2021-03-30 12:00:00 +0000", "snippet": "시각장애인을 위한 서비스를 개발할 때는 접근성에 굉장히 많이 신경을 썼는데, 카페 팀에 와서 개발하면서는 가끔 시간 날 때만 접근성 대응을 해왔습니다ㅠㅠ 개발자와 사용자 모두를 위한 접근성 주제로 Let’Swift 행사가 온라인으로 열려서 들었습니다.개발자를 위한 가이드류성두님이 발표를 해주셨는데 접근성에 대해 많은 관심을 갖고 개발하시는 것 같았습니...", "content": "시각장애인을 위한 서비스를 개발할 때는 접근성에 굉장히 많이 신경을 썼는데, 카페 팀에 와서 개발하면서는 가끔 시간 날 때만 접근성 대응을 해왔습니다ㅠㅠ 개발자와 사용자 모두를 위한 접근성 주제로 Let’Swift 행사가 온라인으로 열려서 들었습니다.개발자를 위한 가이드류성두님이 발표를 해주셨는데 접근성에 대해 많은 관심을 갖고 개발하시는 것 같았습니다.접근성 지원을 하면 자동으로 따라오는 것들확장성 있는 UI를 만들 수 있음디자이너 분들도 확장성 있는 디자인을 하고 싶어함Height를 고정하고 싶지 않을 수 있음디자인은 확장성 있게 했는데, 개발에서 확장성 없게 만들게 될 수 있음높이를 고정해두면 위아래가 짤리는 케이스가 있을 수 있음Dynamic Type으로 UI를 대응한다면, 어떤 디바이스가 나오더라도 대응할 수 있음!기본이 튼튼해짐 애플의 컨트롤 들이 얼마나 많은 것들을 고려해서 만들어졌는지 알 수 있음 -&gt; 기본 컨트롤의 공식 문서를 한번이라도 더 보게 됨 -&gt; 개발 역량이 확장됨UI 테스트 보이스 오버랑 똑같은 방식으로 접근함 보이스 오버가 안되면 UI 테스트를 접근할 수 없음오픈소스 컨트리뷰트 가능성 오픈소스에 접근성이 잘 안되어 있는 경우가 많음혼자하지 않기 신나서 혼자 접근성 대응을 다 하지 않기 혼자서 이러한 고민들을 할 수 없음 오히려 팀원들이 접근성 지원을 안좋게 생각할 수 있음 ex) 왜 이런 상황에서 글씨가 커지나…? 디자이너, 개발자 공감대 형성이 필요함함께 하자고 하면 듣게될 말들 거기까지 신경 쓸 여유가 없어 소수의 고객들 소수의 샤오미 폰을 쓰는 고객들이 있다해도 대응 할 것 버그라는게 원래 소수의 사람들에게 나타남 언제나 소수의 사람들을 위해서 버그를 고치고 있음 차별이 있음을 직시하기 기업은 돈을 버는 곳이야 돈을 버는 곳이지만, 법도 지켜야 함 장애인 차별 금지법이 있음 ㅇㅇ장애인이 우리 앱을 쓰겠어? 시각장애인 사용자 관점한빛맹학교 김찬홍님 발표 접근성 = “닿을 수 있음” 접근성 지원 = “가능성을 여는 것”보이스오버 사용하는 방법 오른쪽으로 쓸거나 왼손으로 쓸면서 사용 손가락으로 화면을 끌면서 탐색할 수 있음 앱 선택시에 다음줄로 넘어갈 때 소리로 구분되어 있음 두 손가락으로 화면을 좌우로 쓸면: 화면 뒤로가기 세손가락으로 화면을 스크롤 할 수 있음개발자들이 조금 더 신경써서 접근성을 대응하면 누군가에게는 굉장히 큰 즐거움을 줄 수 있다는 것을 알게되었습니다.접근성 접근성이 개선되는건지 먼저 물어보기 설계 단계부터 접근성을 고려하기처음부터 접근성을 고려하면 접근성 지원이 잘 된 앱들느낀점개발 초기 단계부터 접근성을 고려해야겠다는 생각을 하게 되었습니다. 최근 개발을 할때는 기능 요구사항을 먼저 다 만들고 나서 시간이 확보되면 접근성 대응을 하는 식으로 접근했는데, 솔직히 이렇게 하면 한계가 있었습니다. UI 공통 모듈을 만들고 거기에 기본적인 접근성 대응을 해주면 좋을 것 같다는 생각이 들었습니다. 그리고 다이나믹 폰트 지원을 신경쓰지 않고 UILabel을 고정 크기고 만들고는 했는데… 전맹 시각장애만 근처에서 봤던 경험에 VoiceOver 음성만 신경썼던 것을 반성하게 되었습니다. 시간을 들여서 좀 더 접근성에 대해 문서도 좀 더 찾아봐야겠습니다." }, { "title": "Swift 객체 외부에서 객체가 해제되는 것 감지하기", "url": "/posts/DeallocWatcher/", "categories": "", "tags": "", "date": "2021-03-30 03:25:00 +0000", "snippet": "iOS 앱 개발하면서 NotificationCenter를 많이 사용하게 되는데요. 특정 객체의 행동을 추척할 때 유용하게 쓸 수 있습니다. addObserver(_:selector:name:object:)를 사용해서 옵저버를 등록해 둔 경우에는, 해당 객체가 메모리에서 해제될 때 옵저버도 자동으로 함께 삭제됩니다. removeObserver(_:)를 ...", "content": "iOS 앱 개발하면서 NotificationCenter를 많이 사용하게 되는데요. 특정 객체의 행동을 추척할 때 유용하게 쓸 수 있습니다. addObserver(_:selector:name:object:)를 사용해서 옵저버를 등록해 둔 경우에는, 해당 객체가 메모리에서 해제될 때 옵저버도 자동으로 함께 삭제됩니다. removeObserver(_:)를 호출할 필요가 없는 것이죠.이슈여기에 예외가 있습니다. addObserver(forName:object:queue:using:)를 사용하는 경우에는 직접 removeObserver(_:)를 호출해줘야 합니다. 클로저를 넘겨주기 때문에 OS 내부에서 해당 클로저를 강한 참조했을 것으로 추측됩니다. [removeObserver 문서] 그렇다면 개발자가 실수할 가능성이 있습니다. deinit 때에 removeObserver(_:)를 호출해주지 않을 수도 있죠.개선이런 동작을 관리해주는 객체를 만들면 어떨까요? 저희 회사 팀에서는 addObserver(_:selector:name:object:)의 결과값을 래핑해서 관리해주는 객체를 이미 사용하고 있습니다. 하지만 여전히 removeObserver(_:)를 호출해줘야 합니다ㅜ 해당 객체를 감시하고 있다가 필요시 자동으로 removeObserver(_:)를 호출해주는 코드를 만들어보겠습니다.https://stackoverflow.com/questions/28670796/can-i-hook-when-a-weakly-referenced-object-of-arbitrary-type-is-freed 스택 오버플로우 내용을 먼저 참고해보겠습니다. AssociatedObject를 특정 객체에 정의를 해주면 해당 객체가 메모리에서 해제될 때 AssociatedObject도 함께 해제되는 원리를 이용했습니다.func addObserver(for key: AnyObject, name: Foundation.Notification.Name, object: Any? = nil, queue: OperationQueue? = OperationQueue.main, using completion: @escaping (Notification) -&gt; Void) { // (1) 객체의 주소값 가져오기 let forKey = describing(key) // (2) 객체가 해제되는 것을 감시하는 역할 let watcher = DeallocWatcher { [unowned self] in // (4) 객체가 메모리에서 해제됨 self.removeObserver(for: forKey) // 토큰을 내부 dictionary에서 제거 } // (3) 객체에 DeallocWatcher를 프로퍼티로 등록해줌 objc_setAssociatedObject(key, forKey, watcher, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) let token = NotificationCenter.default.addObserver(forName: name, object: object, queue: queue) { (noti) in completion(noti) } // 토큰을 내부 dictionary에 저장}private func describing(_ objRef: AnyObject) -&gt; String { return String(describing: Unmanaged&lt;AnyObject&gt;.passUnretained(objRef).toOpaque())}다시 한번 과정을 살펴보겠습니다. 등록을 원하는 객체의 주소값을 가져와서 key로 사용합니다. 객체가 해제되는 것을 감시하는 Class 하나를 만들어줍니다. objc_setAssociatedObject를 통해서 객체에 동적으로 프로퍼티를 등록해줍니다. 객체가 메모리에서 해제되면 DeallocWatcher의 deinit이 호출됩니다. 그러면 등록된 클로저도 호출됩니다. 클로저가 호출되었을 때 해당 key 값으로 removeObserver를 해줍니다.결론이런식으로 하면 객체를 상속받거나 수정하지 않고도 객체 외부에서 메모리 해제를 감지할 수 있습니다. 비슷한 원리를 사용해서 다른 곳에서도 활용할 수 있을 것 같습니다. 예제가 조금 어려웠네요ㅎ;; 조금 더 좋은 예제가 있으면 나중에 한번 더 글을 써보려 합니다. 도움이 되었으면 좋겠습니다 🙏🙏" }, { "title": "Cocoa Internals: 1장 객체 (1.1 ~ 1.2)", "url": "/posts/CocoaInternals-1/", "categories": "CocoaInternals", "tags": "swift, objective-c, CocoaInternals", "date": "2021-03-27 13:35:00 +0000", "snippet": "애플 플랫폼에 대한 기초 정리를 위해 김정님의 코코아 인터널스 책을 공부합니다. 생각보다 진짜 어렵네요 🤣🤣 1.1 클래스와 객체 인스턴스, 1.2 객체 정체성과 등가성에 관한 정리입니다.스위프트 중간 언어(SIL)스위프트에서 기계어 까지 가는 여정에 스위프트 중간 언어라는게 있다고 합니다. 컴파일러가 알아서 기계어로 번역해주는것만 알았지, 이렇게 중...", "content": "애플 플랫폼에 대한 기초 정리를 위해 김정님의 코코아 인터널스 책을 공부합니다. 생각보다 진짜 어렵네요 🤣🤣 1.1 클래스와 객체 인스턴스, 1.2 객체 정체성과 등가성에 관한 정리입니다.스위프트 중간 언어(SIL)스위프트에서 기계어 까지 가는 여정에 스위프트 중간 언어라는게 있다고 합니다. 컴파일러가 알아서 기계어로 번역해주는것만 알았지, 이렇게 중간언어가 있다는 사실은 모르고 있었습니다. SIL을 통해서 최적화 과정을 거친뒤에 기계어로 변환됩니다. 책에 나와 있는 과정을 그대로 옮기면 아래와 같습니다. 사실 아직 제대로 이해가 되지는 않습니다…;;Swift -&gt; `Swift 프론트엔드` -SIL-&gt; `SIL 최적화` -SIL-&gt; `LLVM IR 최적화` -SIL-&gt; `코드 생성기` -&gt; 기계코드 SIL의 목적은 프로그래머가 입력한 Swift 소스 코드와 LLVM IR간의 표현 차이를 메꾸는 것이라고 합니다. 링크에 좀 더 자세한 컴파일 과정이 있습니다.구문분석(AST) -&gt; 의미분석 -&gt; 모듈 임포트 -&gt; SIL 생성 -&gt; SIL 정규화 -&gt; SIL 최적화 -&gt; LLVM IR 생성 -&gt; ...이 과정을 보더라도 아직 이해가 잘 되지 않습니다. 위의 링크에는 각 과정마다 더 자세한 설명이 있습니다. 구문분석 부분을 보면 학부 컴파일러 수업 때 들었던 Paser에 대한 내용도 있습니다. https://github.com/apple/swift/tree/main/lib/Parse 에 내용이 있습니다. (애플 코드도 라인이 꽤 긴데… 좀 더 추상화 하거나 파일을 나누지 않은 이유가 무엇일지 궁금하네요ㅋㅋ…) 나머지 과정들도 해당 레포를 보면 열어볼 수 있습니다.객체코드를 작성하는 과정보다 객체 중심으로 생각하는 과정이 더 중요하다. (p.17)구현을 따라하는 과정보다 추상화를 어떻게 시킬 건지 고민해보는 노력이 중요하다는 생각이 듭니다. 요즘엔 그렇게 추상화에 대한 고민을 어느 정도 했으면 코드로 작성해보는 것 또한 놓치지 않아야 겠다는 생각을 하고 있습니다.메모리 구조한번쯤 메모리 구조를 본적이 있을 텐데 아래와 같이 생겼습니다. 클래스와 인스턴스는 힙 공간에 위치하게 되고, 그 인스턴스를 가리키는 포인터는 스택 공간에 자리잡게 됩니다.(High Memory)스택(Stack) // ⬇️ 위에서 아래로 쌓아감빈공간힙(Heap) // ⬆️ 아래에서 위로 쌓아감심벌(BSS)데이터(DATA)텍스트(TEXT)(Low Memory)그런데 왜…? 스택과 힙이 왜 빈공간을 끼고서 서로를 향해 쌓아가는지 궁금증이 생겼습니다. 사용할 공간을 알고 있는 유형과 사용할 공간을 동적으로 정하는 유형으로 나눠집니다. 메모리라는 한 공간에서 두 개의 유형을 다룰 수 있는 장점이 있습니다. 스택과 힙에 대해서 간단히 알아보겠습니다.스택 컴파일 타임에 크기 결정되는 것들 저장 이미 할당된 공간을 사용하기 때문에 속도가 빠름 LIFO 가장 늦게 저장된 데이터가 먼저 인출됨 High Memory -&gt; Low Memory 방향으로 할당됨 무한으로 이어지는 루프가 있으면 stack overflow가 발생한다. -&gt; 결국 세그멘테이션 오류 발생 func foo() -&gt; Int { foo()} 힙 사용자가 직접 관리하는 메모리 영역 동적으로 메모리 공간 할당 Low Memory -&gt; High Memory 방향으로 할당됨 여러 스레드가 있어도 하나의 힙 영역을 사용함객체 예외성모든 코코아 객체 인스턴스가 힙 영역에 생성되는 것은 아닙니다. NSString 같은 경우에는 예외입니다…!! 문자열은 텍스트 영역에 저장됩니다. 동일한 문자열을 반복해서 사용하면 같은 텍스트 영역을 사용합니다. 이걸 문자열 인터닝(string interning) 이라고 부릅니다.출처 코코아 인터널스 [번역] SIL(Swift Intermediate Language), 일단 시작해보기까지 스택(Stack)과 힙(Heap) 차이점 자바 메모리 관리 - 스택 &amp; 힙 스택 오버플로" }, { "title": "[Combine 책 정리] Chatper 3: Transforming Operators", "url": "/posts/Combine3/", "categories": "combine", "tags": "combine, swift", "date": "2021-01-12 03:07:00 +0000", "snippet": "이번 챕터는 Operator!Operators and publishers operator method는 사실 publisher를 return 함 upstream data -&gt; operator 에서 가공 -&gt; downstream으로 전달 error handling을 위한 operator가 아니면, error를 downstream으로 흘려...", "content": "이번 챕터는 Operator!Operators and publishers operator method는 사실 publisher를 return 함 upstream data -&gt; operator 에서 가공 -&gt; downstream으로 전달 error handling을 위한 operator가 아니면, error를 downstream으로 흘려보내줌 (이번 챕터에서는 에러 핸들링 다루지 않음)Collecting Valuescollect() 개별 value -&gt; array로 변경 value를 버퍼에 쌓고, completion 때 array로 만들어줌example(of: \"collect\") { [\"A\", \"B\", \"C\", \"D\", \"E\"].publisher .collect(2) // stream을 2개씩 묶은 array로 만들어줌 .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) }) .store(in: &amp;subscriptions)}——— Example of: collect ———[\"A\", \"B\"][\"C\", \"D\"][\"E\"] // collect(2)가 채워지기 전에 stream이 끝나서 [\"E\"]로 출력됨finishedcollect(): 숫자 지정하지 않은 collect는completion 될 때까지 무한정 array를 채울 수 있기 때문에 메모리 관리에 주의Mapping valuesmap(_:)Swift의 standard map 처럼 동작함let formatter = NumberFormatter()formatter.numberStyle = .spellOut[123, 4, 56].publisher .map { formatter.string(for: NSNumber(integerLiteral: $0)) ?? \"\" } .sink(receiveValue: { print($0) }) .store(in: &amp;subscriptions)——— Example of: map ———one hundred twenty-threefourfifty-sixMap key pathslet publisher = PassthroughSubject&lt;Coordinate, Never&gt;()publisher .map(\\.x, \\.y) .sink(receiveValue: { x, y in print(\"The coordinate at (\\(x), \\(y)) is in quadrant\", quadrantOf(x: x, y: y)) }) .store(in: &amp;subscriptions)publisher.send(Coordinate(x: 10, y: -8))publisher.send(Coordinate(x: 0, y: 5))The coordinate at (10, -8) is in quadrant 4The coordinate at (0, 5) is in quadrant boundary keyPath를 통해 바로 매핑해주는 방법 3개까지 프로퍼티 매핑이 가능함 .map { ($0.x, $0.y) } 보다 조금 더 간결하다는 점은 장점tryMap(_:)Just(\"Directory name that does not exist\") .tryMap { try FileManager.default.contentsOfDirectory(atPath: $0) } .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) }) .store(in: &amp;subscriptions)failure(Error Domain=NSCocoaErrorDomain Code=260 \"The folder “Directory name that does not exist” doesn’t exist.\" UserInfo={NSUserStringVariant=( Folder), NSFilePath=Directory name that does not exist, NSUnderlyingError=0x6000023e1ad0 {Error Domain=NSPOSIXErrorDomain Code=2 \"No such file or directory\"}})tryMap을 쓰면 클로저 안에서 error를 throw할 수 있음Flattening publishersflatMap(maxPublishers:_:_)여러개의 publisher upstream -&gt; single downstream으로 변환func decode(_ codes: [Int]) -&gt; AnyPublisher&lt;String, Never&gt; { Just( codes.compactMap { code in guard (32...255).contains(code) else { return nil } return String(UnicodeScalar(code) ?? \" \") } .joined() ) .eraseToAnyPublisher()}[72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33] .publisher .collect() .flatMap(decode) .sink(receiveValue: { print($0) }) .store(in: &amp;subscriptions)Hello, World!여기서는 publisher에서 방출된 array를 단일 string으로 변경해줌이걸로는 별로 와닿지 않는다…다수의 upstream으로 부터 무한정 value가 전달되면 memory 이슈가 발생하게 된다그래서 maxPublishers에 Demand를 입력하면 되는데…이번 챕터에서는 이것에 대한 예제가 없다ㅠ 챕터19가서 확인하라고 함Replacing upstream outputreplaceNil(with:)optional을 특정 값으로 바꿔줌[\"A\", nil, \"C\"].publisher .eraseToAnyPublisher() // Combine Bug 방어 위해 사용 .replaceNil(with: \"-\") // nil -&gt; \"-\" .sink(receiveValue: { print($0) }) .store(in: &amp;subscriptions)A-CeraseToAnyPublisher가 특이하게 끼어들어가 있는데Combine에 현재는 버그가 있는듯: https://forums.swift.org/t/unexpected-behavior-of-replacenil-with/40800/5위의 체인에서 eraseToAnyPublisher가 없으면 아래와 같은 결과가 나옴Optional(\"A\")Optional(\"-\")Optional(\"C\")?? 를 쓰는거랑 replaceNil을 쓰는건 차이가 있음?? 는 nil result를 만들 수 있음replaceNil은 nil이 아닌 result만 만들 수 있음만약 위의 체인에서 아래와 같이 변경한다면.replaceNil(with: \"-\" as String?)이렇게 에러가 뜨게됨replaceEmpty(with:)upstream에서 value가 emit되지 않고 completion 되면, value를 하나 넣어주는 것let empty = Empty&lt;Int, Never&gt;()empty .replaceEmpty(with: 1) .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) }) .store(in: &amp;subscriptions)1finishedIncrementally transforming outputscan(_:_:)value를 누적해서 계산할 수 있음var dailyGainLoss: Int { .random(in: -10...10) }let august2019 = (0..&lt;22) .map { _ in dailyGainLoss } .publisheraugust2019 .scan(50) { latest, current in max(0, latest + current) } .sink(receiveValue: { _ in }) .store(in: &amp;subscriptions)Challenge: Create a phone number lookup using transforming operators 도전과제: 전화번호 찾기…! 10자의 숫자 또는 문자를 받음 연락처를 찾음 input .map(convert) .replaceNil(with: 0) .collect(10) .map(format) .map(dial) .sink(receiveValue: { print($0) })——— Example of: Create a phone number lookup ———Contact not found for 000-123-4567Dialing Marin (408-555-4321)...Dialing Shai (212-555-3434)...미리 만들어진 함수들을 operator로 끼워넣었는데,레고 블럭 조립하는 기분이었다.그걸 느끼게 해주는 도전과제인듯" }, { "title": "[Combine 책 정리] Chapter 2: Publishers & Subscribers", "url": "/posts/Combine-Chapter2/", "categories": "combine", "tags": "combine, swift", "date": "2021-01-06 10:51:00 +0000", "snippet": "챕터2 부터는 실습 위주Hello Publisherexample(of: \"Publisher\") { // 1 let myNotification = Notification.Name(\"MyNotification\") // 2 let publisher = NotificationCenter.default .publisher(for: myNotific...", "content": "챕터2 부터는 실습 위주Hello Publisherexample(of: \"Publisher\") { // 1 let myNotification = Notification.Name(\"MyNotification\") // 2 let publisher = NotificationCenter.default .publisher(for: myNotification, object: nil) // 3 let center = NotificationCenter.default // 4 let observer = center.addObserver( forName: myNotification, object: nil, queue: nil) { notification in print(\"Notification received!\") } // 5 center.post(name: myNotification, object: nil) // 6 center.removeObserver(observer)}——— Example of: Publisher ———Notification received!이 예제는 조금 맞지 않는 면이 있는데, 이벤트가 publisher로 부터 나온게 아니기 때문.Subscriber가 등록되어야 Publisher가 활성화 됨.Hello Subscirberexample(of: \"Subscriber\") { let myNotification = Notification.Name(\"MyNotification\") let publisher = NotificationCenter.default .publisher(for: myNotification, object: nil) let center = NotificationCenter.default // 1 let subscription = publisher .sink { _ in print(\"Notification received from a publisher!\") } // 2 center.post(name: myNotification, object: nil) // 3 subscription.cancel()}——— Example of: Subscriber ———Notification received from a publisher!sink 메소드에 대해 알아보자.https://developer.apple.com/documentation/combine/record/sink(receivevalue:) Failure = Never Subscriber를 만들고 backpressure를 무제한 값으로 요청.let integers = (0...3)integers.publisher .sink { print(\"Received \\($0)\") }// Prints:// Received 0// Received 1// Received 2// Received 3Justexample(of: \"Just\") { // 1 let just = Just(\"Hello world!\") // 2 _ = just .sink( receiveCompletion: { print(\"Received completion\", $0) }, receiveValue: { print(\"Received value\", $0) }) _ = just .sink( receiveCompletion: { print(\"Received completion (another)\", $0) }, receiveValue: { print(\"Received value (another)\", $0) })}——— Example of: Just ———Received value Hello world!Received completion finishedReceived value (another) Hello world!Received completion (another) finishedhttps://developer.apple.com/documentation/combine/just 각 subscriber에게 output 한번만 emit 후 finsih Publishers.catch에서 value를 교체해줄 때 유용함 catch를 써봐야 제대로 공감할 듯 catch는 failed publisher를 다른 publisher로 바꿔주는 거 Just는 failure가 없음 값이 반드시 있음Assignexample(of: \"assign(to:on:)\") { // 1 class SomeObject { var value: String = \"\" { didSet { print(value) } } } // 2 let object = SomeObject() // 3 let publisher = [\"Hello\", \"world!\"].publisher // 4 _ = publisher .assign(to: \\.value, on: object)}——— Example of: assign(to:on:) ———Helloworld!assign on에 들어갈 object는 class만 가능example(of: \"assign(to:)\") { // 1 class SomeObject { @Published var value = 0 } let object = SomeObject() // 2 object.$value // $value로 접근하면 publisher로 접근 가능 .sink { print($0) } // 3 (0..&lt;10).publisher .assign(to: &amp;object.$value) // return 값이 없음}——— Example of: assign(to:) ———0012345678  왜 assign(to:on:)을 안쓰고, assign(to:)를 쓸까?class MyObject { @Published var word: String = \"\" var subscriptions = Set&lt;AnyCancellable&gt;() init() { [\"A\", \"B\", \"C\"].publisher .assign(to: \\.word, on: self) .store(in: &amp;subscriptions) }}// 다음에서 발췌: By Marin Todorov. ‘Combine: Asynchronous Programming with Swift.’ Apple Books.이렇게 사용하면 subscription -&gt; self -&gt; subscription 으로 강한 순환 참조에 걸림이걸 방지하기 위해서 assign(to: &amp;$word)를 사용할 수 있음Hello Cancellable subscirber가 더 이상 값을 받을 필요 없을 때 cancel() 사용 cancel()을 직접 호출하지 않으면, deinit될 때까지 구독됨Understanding what’s going on1. 구독 시작2. Subscription 객체 전달3. request value: Backpressure4. values 여러개 전달 가능5. completion은 한번만Publisher는 프로토콜로 되어 있음.내부를 한번 보자public protocol Publisher { // 1: emit할 수 있는 value associatedtype Output // 2: 예외 발생할 경우 사용되는 에러. // 에러가 발생하지 않는다고 보장할 수 있으면, `Never` 사용 associatedtype Failure : Error // 4: publisher에 subscirber를 붙이기 위해서 호출 됨 func receive&lt;S&gt;(subscriber: S) where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input}extension Publisher { // 3 public func subscribe&lt;S&gt;(_ subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input}Subscriber도 프로토콜public protocol Subscriber: CustomCombineIdentifierConvertible { // 1: receive 할 수 있는 value associatedtype Input // 2: receive 할 수 있는 error associatedtype Failure: Error // 3 func receive(subscription: Subscription) // 4 func receive(_ input: Self.Input) -&gt; Subscribers.Demand // 5 func receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)}Subscription을 통해 Publisher와 Subscriber 간에 소통public protocol Subscription: Cancellable, CustomCombineIdentifierConvertible { func request(_ demand: Subscribers.Demand)}demand 통해서 backpressure를 정의함.subscirber가 얼마나 value를 더 받을 수 있는지 알려줌.https://developer.apple.com/documentation/combine/subscribers/demand.max(Int)로 들어온 값 만큼 + 해줌.음수가 될 수 는 없음.max(2) .max(1) 으로 요청하면 최대 3개 value를 전달받게 됨.max(2) .none 으로 요청하면 최대 2개 value를 전달받게 됨.unlimited로 요청하면 무한정 값을 받게됨 (별로 권장하지 않는 방식인 듯)Creating a custom subscriberexample(of: \"Custom Subscriber\") { // 1 let publisher = (1...6).publisher // 2 final class IntSubscriber: Subscriber { // 3 typealias Input = Int typealias Failure = Never // 4 func receive(subscription: Subscription) { subscription.request(.max(3)) } // 5 func receive(_ input: Int) -&gt; Subscribers.Demand { print(\"Received value\", input) return .none } // 6 func receive(completion: Subscribers.Completion&lt;Never&gt;) { print(\"Received completion\", completion) } } let subscriber = IntSubscriber() publisher.subscribe(subscriber)}——— Example of: Custom Subscriber ———Received value 1Received value 2Received value 3Demand.max(3) 으로 요청했기 때문에 1, 2, 3을 전달 받음만약에 unlimited로 변경하면, 모든 데이터를 다 전달 받음func receive(_ input: Int) -&gt; Subscribers.Demand { print(\"Received value\", input) return .unlimited}——— Example of: Custom Subscriber ———Received value 1Received value 2Received value 3Received value 4Received value 5Received value 6Received completion finishedHello Futureexample(of: \"Future\") { func futureIncrement( integer: Int, afterDelay delay: TimeInterval) -&gt; Future&lt;Int, Never&gt; { Future&lt;Int, Never&gt; { promise in print(\"Original\") DispatchQueue.global().asyncAfter(deadline: .now() + delay) { promise(.success(integer + 1)) } } } // 1 let future = futureIncrement(integer: 1, afterDelay: 3) // 2 future .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) }) .store(in: &amp;subscriptions) future .sink(receiveCompletion: { print(\"Second\", $0) }, receiveValue: { print(\"Second\", $0) }) .store(in: &amp;subscriptions)}——— Example of: Future ———Original2finishedSecond 2Second finishedFuture는 좀 특이함init될 때 즉시 실행되고 다시 실행되지 않음.그래서 위의 예제에서 “Original”이 한번만 호출됨subscriber가 추가되면 만들어진 value를 재사용하고, completion 호출함Hello Subjectexample(of: \"PassthroughSubject\") { // 1 enum MyError: Error { case test } // 2 final class StringSubscriber: Subscriber { typealias Input = String typealias Failure = MyError func receive(subscription: Subscription) { subscription.request(.max(2)) } func receive(_ input: String) -&gt; Subscribers.Demand { print(\"Received value\", input) // 3 return input == \"World\" ? .max(1) : .none } func receive(completion: Subscribers.Completion&lt;MyError&gt;) { print(\"Received completion\", completion) } } // 4 let subscriber = StringSubscriber() // 5 let subject = PassthroughSubject&lt;String, MyError&gt;() // 6 subject.subscribe(subscriber) // 7 let subscription = subject .sink( receiveCompletion: { completion in print(\"Received completion (sink)\", completion) }, receiveValue: { value in print(\"Received value (sink)\", value) } ) subject.send(\"Hello\") subject.send(\"World\") // 8 subscription.cancel() // 9 subject.send(\"Still there?\") subject.send(completion: .failure(MyError.test)) subject.send(completion: .finished) subject.send(\"How about another one?\")}——— Example of: PassthroughSubject ———Received value HelloReceived value (sink) HelloReceived value WorldReceived value (sink) WorldReceived value Still there?Received completion failure(__lldb_expr_71.(unknown context at $1102e3024).(unknown context at $1102e3180).(unknown context at $1102e3188).MyError.test)Passthrough subject는 직접 new value를 넣어줄 수 있음// 8 에서는 cancel()을 명시적으로 호출했기 때문에// 9 에서 더이상 sink가 호출되지 않음completion: failure와 finished는 배타적이기 때문에failure가 전달되면 스트림은 종료되게 된다나중에 finished를 보낸다고 해도 효력이 없다example(of: \"CurrentValueSubject\") { // 1 var subscriptions = Set&lt;AnyCancellable&gt;() // 2 let subject = CurrentValueSubject&lt;Int, Never&gt;(0) // 3 subject .print() .sink(receiveValue: { print($0) }) .store(in: &amp;subscriptions) // 4 subject.send(1) subject.send(2) print(subject.value) subject.value = 3 print(subject.value) subject .print() .sink(receiveValue: { print(\"Second subscription:\", $0) }) .store(in: &amp;subscriptions) subject.send(completion: .finished)}——— Example of: CurrentValueSubject ———receive subscription: (CurrentValueSubject)request unlimitedreceive value: (0)0receive value: (1)1receive value: (2)22receive value: (3)33receive subscription: (CurrentValueSubject)request unlimitedreceive value: (3)Second subscription: 3receive finishedreceive finished// 나중에 추가 정리Dynamically adjusting demandsubscriber를 커스텀하게 만들고Demand 컨트롤을 직접 할 수 있음실제 문제해결에서 사용될지는 모르겠음…example(of: \"Dynamically adjusting Demand\") { final class IntSubscriber: Subscriber { typealias Input = Int typealias Failure = Never func receive(subscription: Subscription) { subscription.request(.max(2)) } func receive(_ input: Int) -&gt; Subscribers.Demand { print(\"Received value\", input) switch input { case 1: return .max(2) // 1 case 3: return .max(1) // 2 default: return .none // 3 } } func receive(completion: Subscribers.Completion&lt;Never&gt;) { print(\"Received completion\", completion) } } let subscriber = IntSubscriber() let subject = PassthroughSubject&lt;Int, Never&gt;() subject.subscribe(subscriber) subject.send(1) subject.send(2) subject.send(3) subject.send(4) subject.send(5) subject.send(6)}——— Example of: Dynamically adjusting Demand ———Received value 1Received value 2Received value 3Received value 4Received value 5// 나중에 추가 정리Type erasureexample(of: \"Type erasure\") { // 1 let subject = PassthroughSubject&lt;Int, Never&gt;() // 2 let publisher = subject.eraseToAnyPublisher() // 3 publisher .sink(receiveValue: { print($0) }) .store(in: &amp;subscriptions) // 4 subject.send(0)}——— Example of: Type erasure ———0type erasure를 하면 외부에서 접근할 때 subject의 구체적인 타입을 숨길 수 있음위의 예제에서는 PassthroughSubject 인데, subject를 바로 노출하면 send(_:)를 해버릴 수 있어서 외부에 노출할 경우 의도치 않은 동작을 유도할 수 있음" }, { "title": "[Combine 책 정리] Chapter 1: Hello, Combine!", "url": "/posts/Hello-Combine/", "categories": "combine", "tags": "combine, swift", "date": "2021-01-03 13:35:00 +0000", "snippet": "책의 목표 추상적으로 들리는 컴바인의 개념을 이해 한 챕터씩 따라가면서 컴바인이 무엇을 해결하고자 하는지 배워나감https://www.raywenderlich.com/books/combine-asynchronous-programming-with-swift/v2.0애플에서는 Combine을 통해 이벤트 처리를 위한 선언적 접근을 함 Delegat...", "content": "책의 목표 추상적으로 들리는 컴바인의 개념을 이해 한 챕터씩 따라가면서 컴바인이 무엇을 해결하고자 하는지 배워나감https://www.raywenderlich.com/books/combine-asynchronous-programming-with-swift/v2.0애플에서는 Combine을 통해 이벤트 처리를 위한 선언적 접근을 함 Delegate나 Completion Handler 구현 대신 이벤트 소스에 대한 Single processing chain을 만들 수 있음비동기 프로그래밍 (Asynchronous programming) 스레드 1개가 코드 실행 결과로 “Tom Harding”이 출력됨을 보장 가능begin var name = \"Tom\" print(name) name += \" Harding\" print(name)end// 다음에서 발췌: By Marin Todorov. ‘Combine: Asynchronous Programming with Swift.’ Apple Books. 스레드 2개가 비동기적으로 코드를 실행 코드를 실행할 때마다 결과가 달라지기도 함 Thread 2 가 끼어들면서 결과물은 “Billy Bob Harding”이 되어버림…--- Thread 1 ---begin var name = \"Tom\" print(name)--- Thread 2 ---name = \"Billy Bob\"--- Thread 1 --- name += \" Harding\" print(name)end// 다음에서 발췌: By Marin Todorov. ‘Combine: Asynchronous Programming with Swift.’ Apple Books.Foundation and UIKit/AppKit 상황: 모바일 앱을 만들 때 비동기 프로그래밍을 일상적으로 하고 있음. 문제: 비동기 코드는 재현하기 어려운 이슈들을 많이 만들어냄 해결: Combine이 탄생!!!Combine 장점 당신의 코드에 통합하기 쉬움. 애플은 Combine API를 Foundation Framework에 긴밀하게 통합하고 있음. // 이게 RxSwift 보다 좋은 점이 아닐까 싶음. RxSwift는 외부 라이브러리. 코코아 프레임워크와 통합하기 위해서 많은 노력이 필요. SwiftUI와 함께 사용하기도 좋음. API에 대한 테스트도 잘되어 있습니다. 데이터 모델 부터 네트워크 레이어 그리고 UI까지 모두 Combine을 사용 가능Foundation of Combine 선언형, 반응형 프로그래밍은 새로운 컨셉이 아님. 오랫 동안 사용되어 왔지만 지난 10년동안 주목 받음.Rx 라이브러리들의 역사 2009년 MS에서 Rx.NET을 출시. 2012년에는 Rx.NET을 오픈소스로 출시 그 때 부터 다른 언어들도 동일한 컨셉을 사용하기 시작했습니다. 현재는 Rx를 포팅한 많은 라이브러리들이 있음 (RxJS, RxKotlin, RxScala, RxPHP…) 읽어볼만 한 기사: https://zdnet.co.kr/view/?no=20161010104628 Reactive Programming 관련된 영상이 있어서 정리해봤습니다 link애플 플랫폼 용 반응형 프로그래밍 라이브러리 RxSwift: Rx standard 구현 ReactiveSwift: Rx로 부터 영감을 받음 Interstellar: 커스텀하게 구현. // 이건 잘 모르겠음// TODO: RxSwift, ReactiveSwift는 어떻게 다른지 찾아보기컴바인 도입 컴바인은 Rx와 다르지만 비슷한 표준인 Reactive Streams를 구현. Reactive Streams과 Rx의 대부분의 핵심 컨셉은 동일. iOS 13/macOS Catalina 부터 애플은 Combine으로 반응형 프로그래밍을 도입.Combine basics컴바인 3가지 주요 부분 Publisher Operator Subscriber// WWDC 2019 정리했던 글(https://medium.com/@hongseongho/introducing-combine-%EC%A0%95%EB%A6%AC-9e42b0fed56d) 다시 읽기자세한 건 챕터2(Publishers &amp; Subscribers)에서…챕터1 에서는 각 타입들의 역할 파악.PublishersPublisher는 value들을 보내는(emit) 역할.Publisher가 emit 할 수 있는 이벤트 종류 Output Completion: successful completion Failure: completion with an error Publisher는 Output을 안보내고 있거나 여러번 보낼 수 있으며, Completion 이나 Failure를 한번 보내고 나면 더 이상의 이벤트는 보낼 수 없습니다.ex)Publisher&lt;Int, Never&gt;-[1]-[3]-[1]-[5]-[Completion]--[1]-[3]-[1]-[Failure]-특징 3가지 이벤트로 모든 종류의 동적 데이터를 표현 가능 delegate를 추가하거나 completion callback을 주입 필요없음 // 아직까지 그렇게 동의하지 못하는 부분. publisher도 어차피 찾아서 연결해줘야하는 건 동일한데 큰 우위에 있다고 볼 수 있을까? Publisher는 에러 핸들링이 내장 // 이거 아직 이해 못함… Error를 emit할 수 있다는 점을 뜻하는 걸까? Publisher는 2개의 제니릭을 기반으로 구성 Publisher.Ouput: output value. Publisher.Failure: 에러 전달. 에러가 발생할 일이 없으면, Never 라는 타입으로 정의하면 됨 Operators정의 Operator는 Publisher 프로토콜에 선언되어 있음. 같거나 새로운 Publisher를 반환하는 메소드. Operator들을 체이닝해서 사용할 수 있기 때문에 유용함.장점 Operator들은 독립적이고 조합가능하기 때문에, 복잡한 로직을 구현하는데 조합(Combine) 가능. 항상 Input &amp; Ouput(Upstream &amp; Downstream)을 가지기 때문에 shared state를 피할 수 있음. (앞에서 나왔던 동시성 이슈)비동기 코드가 끼어들어 당신의 데이터를 중간에 변경할 일이 없음Subscribers정의모든 구독은 subscriber로 끝남.전달받은 value나 completiopn event로 작업을 수행.2개의 내장된 subscriber sink: output value와 completion을 받을 수 있는 클로저를 제공할 수 있음 assign: output을 key path를 통해 data model의 property 나 UI control에 바로 바인딩 할 수 있음Subscriptions Note: 책의 subscription 이라는 용어는 아래를 설명하기 위해 사용됨 1. subscription 프로토콜2. 프로토콜을 준수하는 오브젝트3. publisher, operator, subscriber의 전체 chain중요subscription의 끝에 subscriber를 추가 -&gt; 체이닝의 맨 앞에 있는 publisher를 활성화output을 수신해줄 subscriber가 없으면 publisher는 어떤 value도 전달하지 않음장점 Subscription은 비동기 이벤트들의 체인을 커스텀 코드와 에러 핸들링과 함께 한방에 선언 가능. Full-Combine 이면, 앱 전체의 로직을 subscription 들로 표현 가능. Subscription이 한번 선언되고 나면 콜백을 호출할 필요 없이 시스템이 다 알아서 해줌.메모리 관리 Cacncellable 프로토콜 사용해서 메모리 관리. Subscriber들은 Cancellable을 준수하고 있음. 오브젝트를 메모리에서 해제 -&gt; 모든 subscription은 취소 -&gt; 리소스를 메모리로부터 해제장점 Subscription의 수명을 view controller 같은 오브젝트에 bind 가능. 유저가 view controller를 view stack에서 dismiss -&gt; subscription 취소 해줌조금 더 자동화 [AnyCancellable] Collection 프로퍼티를 만들어서, subscription들을 여기에 담아주기. [AnyCancellable]가 메모리에서 해제될 때 자동적으로 cancel 되고 release 될 것 입니다.기존 코드에 비해 Combine이 더 좋은 점은?편리함, 안전함, 경제적장점 시스템 레벨에 통합되어 있음. 내부에서 privatet API 쓰는 듯 delegate, closure를 만들 필요 없음. 실수 가능성 낮아짐. 재사용성 좋음. 동일한 인터페이스 쓰기 때문. operator를 조합하기 좋음. 비동기 코드에서도 비즈니스 로직에 집중할 수 있음.App architecture 아키텍처에 영향을 미치지는 않음. 선택적으로 적용 가능. MVC, MVVM, VIPER 에서 활용 가능. Combine &amp; SwiftUI의 경우에는 MVC에서 C가 필요 없음.Book projects playground에서 컴바인을 사용해보기 좋음. 책에서 제공하는 playground 부터 시작Key points 컴바인은 비동기 이벤트를 위한 선언적, 반응형 프레임워크 비동기 프로그래밍의 기존 문제를 해결하는 것이 목표 주요 3 타입: publisher (이벤트 발행) -&gt; operator (이벤트 처리, 조작) -&gt; subscriber (결과물 소비)" }, { "title": "TIL: Xcode Archive 오류", "url": "/posts/TIL-Xcode-Archive-%EC%98%A4%EB%A5%98/", "categories": "Xcode", "tags": "", "date": "2020-11-29 00:00:00 +0000", "snippet": "별 것 아니지만, 나중을 위해 기록해둔다.Xcode 12 GM으로 Xcode Archive를 성공적으로 해서, 앱스토어 업로드를 했는데 실패했다.구체적으로 어떤 에러인지 알려주지 않아서 이상하게만 생각했는데, 알고보니 최신 Xcode 12.2가 있었다.회사에서는 아직 Xcode 11.7을 썼던터라 버전 업데이트에 민감하게 반응하지 못하기도 했다.무튼 ...", "content": "별 것 아니지만, 나중을 위해 기록해둔다.Xcode 12 GM으로 Xcode Archive를 성공적으로 해서, 앱스토어 업로드를 했는데 실패했다.구체적으로 어떤 에러인지 알려주지 않아서 이상하게만 생각했는데, 알고보니 최신 Xcode 12.2가 있었다.회사에서는 아직 Xcode 11.7을 썼던터라 버전 업데이트에 민감하게 반응하지 못하기도 했다.무튼 별다른 이유가 없는데 앱스토어로 업로드가 되지 않을때는 Xcode 버전이 최신인지 확인하는 것도 좋겠다.TIL Xcode 업데이트 주기적으로 확인하기 앱스토어 업로드 오류가 발생하면 Xcode 버전이 최신인지 확인하기" }, { "title": "Xcode에서 class의 모든 method에 breakpoint 걸기", "url": "/posts/breakpoint/", "categories": "Xcode", "tags": "Xcode", "date": "2019-10-23 12:55:00 +0000", "snippet": "회사에서 코드를 작성하다 보면 모두지 찾을 수 없는 버그들을 만나기 마련이다. 사방에 함수들이 흩어져 있기 때문에 어떤 함수가 호출되는지 따라갈 수 없는 일도 있다. 그런 코드를 만들지 않기 위해서 역할 분리를 잘 해야겠다는 교훈을 느끼기도 한다. 무튼 지금의 버그를 이겨내야 하니 이 클래스 안에 있는 함수들에 모두 breakpoint를 걸어주자.(l...", "content": "회사에서 코드를 작성하다 보면 모두지 찾을 수 없는 버그들을 만나기 마련이다. 사방에 함수들이 흩어져 있기 때문에 어떤 함수가 호출되는지 따라갈 수 없는 일도 있다. 그런 코드를 만들지 않기 위해서 역할 분리를 잘 해야겠다는 교훈을 느끼기도 한다. 무튼 지금의 버그를 이겨내야 하니 이 클래스 안에 있는 함수들에 모두 breakpoint를 걸어주자.(lldb) breakpoint set -r '\\[ClassName .*\\]$'메소드 명에도 걸 수 있다.(lldb) breakpoint set -n ViewDidLoad이 방법으로 Objc 코드에 있던 사이드 이팩트를 발견할 수 있었다. 보통 의심가는 함수에 하나씩 breakpoint를 걸면서 찾아봤는데, 때로는 이렇게 모든 함수에서 디버깅 하는것이 편할 때도 있다.출처: http://blog.alwawee.com/2012/07/23/setting-breakpoints-on-all-methods-in-xcode/" }, { "title": "Functional Thinking", "url": "/posts/functional-thinking/", "categories": "swift", "tags": "Swift, Functional programming", "date": "2018-10-28 00:00:00 +0000", "snippet": "사실 함수형 사고 보다 RxSwift를 먼저 접하긴 했지만, 먼저 뿌리가 되는 함수형 프로그래밍 부터 알아보고 싶다는 생각이 들었다. RxSwift가 매력적인 프로그래밍 도구가 되어주는 것은 이해했지만, 아직도 남들을 설득하기에 기초가 되는 지식이 부족했기 때문이다.함수형 프로그래밍미리 말해두고 싶은 것은 객체지향과 함수형은 서로 적대적인 관계가 아니...", "content": "사실 함수형 사고 보다 RxSwift를 먼저 접하긴 했지만, 먼저 뿌리가 되는 함수형 프로그래밍 부터 알아보고 싶다는 생각이 들었다. RxSwift가 매력적인 프로그래밍 도구가 되어주는 것은 이해했지만, 아직도 남들을 설득하기에 기초가 되는 지식이 부족했기 때문이다.함수형 프로그래밍미리 말해두고 싶은 것은 객체지향과 함수형은 서로 적대적인 관계가 아니라는 점이다. 코드의 재사용이라는 동일한 목표를 두고 다른 각도에서 바라보는 것이다. 저자가 책의 마지막 부분에서 말하고 있듯이, 다양한 패러다임을 연습해두고 문제에 맞는 방식을 채택하는 것이 좋다.개발자들은 코드를 재사용하고 싶어한다. 클래스를 재사용하는 것에 초점을 맞춘 객체지향 프로그래밍이 있고, 함수를 재사용하는 것에 초점을 맞춘 함수형 프로그래밍이 있다. 함수를 재사용하기 위해서는 함수를 사용할 때마다 다른 결과가 나와서는 안되겠다. 함수형 프로그래밍에서 불변성을 중요하게 생각하는 이유다.커링객체지향에서 함수를 재사용할 방법을 고민하기 보다는 접근제어(private, public 등) 을 어떻게 하면 잘 나눌 수 있을지 고민한 적이 많은 것 같다. 내부에 추가적인 함수를 만들지 않고도 작업이 가능하다.func add(x: Int, y: Int) -&gt; Int { return x + y}위와 같은 함수가 있다고 가정하자. 항상 1 을 더해주는 함수는 어떻게 추가할 수 있을까?func addOne(x: Int) -&gt; Int { return add(x: x, y: 1)}모두가 알고 있듯이 이렇게 만들면 된다. 간단한 일이다. 하지만 항상 2, 3, 4, 5 를 추가해주는 함수도 필요하면 어떻게 될까? 4개의 추가적인 함수가 또 필요하다. 대신 이렇게 한번 해보자.func add(_ x: Int) -&gt; (Int) -&gt; Int { return { y in return x + y }}이렇게 x를 먼저 받아두고 y는 나중에 받을 수 있도록 해주는 함수다. 커링(currying)이라고 부른다. 1, 2, 3, 4, 5 를 더해주는 함수는 이렇게 만든다.let addOne = add(1)let addTwo = add(2)let addThree = add(3)let addFour = add(4)let addFive = add(5)사용할 때는 이렇게 사용한다.addOne(10) // 11addTwo(10) // 12addThree(10) // 13addFour(10) // 14addFive(10) // 15저자는 부분함수와 커링의 개념을 좀 더 명확하게 구분하고자 했다. 간단히 보면 파라미터가 1개인 함수로 만들어주는 것을 커링, 나머지는 부분함수라고 이해했다. 커링의 개념을 조금 더 깊게 알고 싶다면 이 글을 참고하는 것도 도움이 될 것이다. Swift로 라이브러리 형태로 정리된 것은 thoughtbot/Curry가 있으니 사용해보는 것도 좋겠다.메모이제이션내부의 상태를 저장하기 위해서 캐시를 사용하는 경우가 많다. 그 경우에 클래스 내부에서 캐싱을 한다. 이 경우 어디서 캐시를 사용하는지 고려해줘야 한다. 클래스 내부의 어떤 함수가 사용할 수도 있고 아닐 수도 있다. 잠재적인 오류를 품고 있는 것이다.함수형 프로그래밍에서는 캐시를 함수 단위로 풀어가고자 한다. 함수의 리턴 값을 캐싱하는 방법인데 메모이제이션이라고 부른다. 메모이제이션을 사용하면 런타임에 최적화를 맡기게 되어서 성능 향상을 꾀할 수 있다. 그리고 메모이제이션 된 함수의 내부의 값을 다른 함수가 변경하는 것이 어렵기 때문에 잠재적인 오류를 줄일 수 있다.func memoize&lt;T: Hashable, U&gt;(_ function: @escaping (T) -&gt; U) -&gt; (T) -&gt; U { var cache = [T: U]() func memoizedFunction(x: T) -&gt; U { if let cachedValue = cache[x] { return cachedValue } let value = function(x) cache[x] = value return value } return memoizedFunction}let memoizedClassfier = memoize(Classifier.isPerfect)책을 읽으면서 메모이제이션을 swift로 구현해봤다. 위의 예제에서는 func isPerfect() -&gt; Bool 함수 자체를 캐싱한다. 재귀 상황에서도 사용할 수 있으면 좋겠다는 생각이 든다. 애플의 WWDC 세션에서 아래와 같은 코드를 소개했다.func memoize&lt;T: Hashable, U&gt;(_ body: @escaping ((T) -&gt; U, T) -&gt; U) -&gt; (T) -&gt; U { var memo = [T: U]() var result: ((T) -&gt; U)! result = { x in if let q = memo[x] { return q } let r = body(result, x) memo[x] = r return r } return result}let factorial = memoize { factorial, x in x == 0 ? 1 : x * factorial(x - 1) }속도 비교도 함께 있어서 자세히 알고 싶은 사람은 이 글을 읽어보면 좋을 듯 하다. 책의 예제를 따라가면서 실제로 속도 향상이 있는지 궁금했고, 실무에도 적용할 수 있을지 고민해봤다.함수형 자료구조함수형 언어는 부수효과가 없는 순수함수를 선호한다. 그리고 리턴 받은 값을 또 다시 함수에 넣을 수 있어야 좋다. 만약 함수가 예외를 발생시키면 이러한 특성을 깨뜨리게 된다. 그래서 보통 type-safe한 오류 처리방식을 도입한다.책에서는 Either 라는 클래스를 소개하는데 swift에서는 모나드로 값을 한번 감싸서 구현할 수 있다. Optional이나 Result도 이와 같은 역할을 한다. unwrapping 하는 과정을 한번만 거치면 된다. Optional 구현부를 보면 아래와 값을 감싸게 되어있다.public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral { /// The absence of a value. /// /// In code, the absence of a value is typically written using the `nil` /// literal rather than the explicit `.none` enumeration case. case none /// The presence of a value, stored as `Wrapped`. case some(Wrapped)}Result는 이런식으로 구현하면 된다. 책에서 소개한 Either과 같다. Error 내용에 따라 처리해줘야 할 것이 있을 때는 Result를 사용하면 된다.public enum Result&lt;Value, Error: Swift.Error&gt;: ResultProtocol, CustomStringConvertible, CustomDebugStringConvertible { case success(Value) case failure(Error)}에러를 바로 발생시키지 않는다는 개념이기 때문에, lazy를 구현하는데 도움이 된다. 에러의 내용을 확인하려면 한번 더 값을 열어봐야한다.Lazy이번엔 lazy에 대해서 알아보자. 표현의 평가를 가능한 최대로 늦추는 기법 이라고 소개한다. 시간이 많이 걸리는 연산을 최대로 늦출 수 있고, 무한 컬렉션을 만들 수 있다. 자바에서는 이러한 무한 컬렉션을 Stream 으로 도입했고, 비슷한 개념을 RxSwift 에서 사용 가능하다.사실 lazy 라는 것이 그렇게 새롭다고 느껴지진 않았다. swift에서 이미 많이 사용되고 있기 때문이다. UIView를 구성할 때 각 화면 요소들의 생성을 최대한 늦췄다가 필요할 때 생성해서 사용하기도 하고(lazy stored property), collection에 lazy를 적용해서 필요할 때만 값을 생성하거나 필터 하는 방법을 사용한다(lazy collection). lazy stored property에 대한 애플의 예제를 간단히 보자.class DataManager { lazy var importer = DataImporter() var data = [String]() // the DataManager class would provide data management functionality here}let manager = DataManager()manager.data.append(\"Some data\")manager.data.append(\"Some more data\")// the DataImporter instance for the importer property has not yet been created가끔씩 사용되고 생성하는 비용이 크다면 lazy 키워드를 사용해서 생성을 미룰 수 있는 것이다. 위의 예제에서는 importer 가 아직 생성되지 않았다. 아래는 lazy collection에 대한 예제이다.public var keys: LazyMapCollection&lt;Dictionary, Key&gt; { return self.lazy.map { $0.key }}lazy map을 사용해서 map을 연산할 필요가 있을 때만 연산한다. collection에 있는 모든 값에 대해 계산해주는 것이 아니라 사용되는 index의 값만 게산해서 반환하는 방법이다. 만약 collection에 많은 값들이 들어있고 key를 가져오는 것이 가끔 있는 일이라면 유용한 방법이 된다.함수 수준의 재사용글의 초반에 함수형 프로그래밍의 핵심이 함수의 재사용에 있다고 했다. 클래스에 패턴을 적용하는 객체지향처럼, 함수형 프로그래밍에서도 일종의 패턴이 있다.1. 템플릿 메서드기존에 탬플릿 메서드에서는 아래와 같이 구현할 수 있다. 껍데기만 만들어두고 각 함수의 구현부는 클래스에게 맞기는 것이다.protocol Customer { associatedtype Item var plan: [Item] { get } func checkCredit() func checkInventory() func ship() func process()}extension Customer { func process() { checkCredit() checkInventory() ship() }}같은 기능을 수행하는 프로토콜을 만들어보자. 앞서서 3개의 함수를 클래스에서 반드시 구현해야 했다. 물론 checkCredit() { } 처럼 함수를 비워두는 방법도 있겠고, extension에서 구현부를 미리 비워두는 방법도 있겠지만 클로저를 사용한 아래의 방법이 조금 더 깔끔한 것을 알 수 있다.protocol CustomerBlocks { associatedtype Item var plan: [Item] { get } var checkCredit: (() -&gt; Void)? { get } var checkInventory: (() -&gt; Void)? { get } var ship: (() -&gt; Void)? { get } func process()}extension CustomerBlocks { func process() { checkCredit?() checkInventory?() ship?() }}optional로 정의되어 있는 일급 함수들은 nil을 넣어서 생략할 수 있다. 그리고 함수를 호출하는 부분에서는 ? 라는 syntax sugar을 사용해서 간편하게 처리할 수 있다.2. 전략(Strategy)strategy pattern은 알고리즘을 바꿔서 사용할 수 있게 해주는 패턴이다. 곱셈을 두가지 방식으로 구현했다.protocol Calc { func product(n: Int, m: Int) -&gt; Int}class CalcMult: Calc { func product(n: Int, m: Int) -&gt; Int { return n * m }}class CalcAdd: Calc { func product(n: Int, m: Int) -&gt; Int { var result = 0 (1...n).forEach { _ in result += m } return result }}CalcMult과 CalcAdd의 결과값은 같다.class StrategyTest { var listOfStrategies: [Calc] = [CalcMult(), CalcAdd()] func test() { listOfStrategies.forEach { print(10 == $0.product(n: 5, m: 2)) } }}앞서 템플릿 메서드에서 사용했던 것처럼 일급 함수를 사용해보자. 함수를 바로 배열에 넣어서 사용했다.class StrategyTest { static func testExp() { var listOfExp: [(Int, Int) -&gt; Int] = [ { n, m in n * m}, { n, m in var result = 0 (1...n).forEach { _ in result += m } return result } ] listOfExp.forEach { print(10 == $0(5, 2)) } }}3. 플라이웨이트 디자인 패턴과 메모이제이션플라이웨이트는 같은 종류의 모든 상품을 대표하는 표준객체라는 개념을 사용한다. 싱글톤에서 각 상품에 대한 정보를 공유한다.class CompFactory { var types: [String: Computer] = [:] static let sharedInstance: CompFactory = CompFactory() init() { types[\"MacBookPro6_2\"] = Laptop() types[\"SunTower\"] = Desktop() } func ofType(_ computer: String) -&gt; Computer? { return types[computer] }}func testCompFactory() { let bob = AssignedComputer(computerType: CompFactory.sharedInstance.ofType(\"MacBookPro6_2\"), userID: \"Bob\") let steve = AssignedComputer(computerType: CompFactory.sharedInstance.ofType(\"MacBookPro6_2\"), userID: \"Bob\") print(bob.computerType === steve.computerType)}각 type에 대한 정보를 캐시해두었다. 이 글의 앞부분에서 캐싱을 메모이제이션으로 대체할 수 있다고 했다. 그렇다면 플라이웨이트 패턴을 메모이제이션을 활용해서 만들어보자. memoize() 함수는 앞부분에서 구현했던 것을 그대로 사용했다. 싱글톤을 쓰지 않고도 보다 간결하게 표현할 수 있게 되었다.func testMemoize() { let computerOf: (String) -&gt; Computer? = { type in let of: [String: Computer] = [\"MacBookPro6_2\": Laptop(), \"SunTower\": Desktop()] return of[type] } let computerOfType = memoize(computerOf) let bob = AssignedComputer(computerType: computerOfType(\"MacBookPro6_2\"), userID: \"Bob\") let steve = AssignedComputer(computerType: computerOfType(\"MacBookPro6_2\"), userID: \"Bob\") print(bob.computerType === steve.computerType)}4. 팩토리와 커링주어진 조건에 따라 다른 값을 리턴하는 것이 팩토리 의 본질이다. 이 글의 제일 앞부분에서 다뤘던 커링을 떠올려보자. 함수를 주어진 조건에 따라 다른 함수로 만든다.let addOne = add(1)let addTwo = add(2)let addThree = add(3)let addFour = add(4)let addFive = add(5)메타 프로그래밍함수형 프로그래밍 개념을 제대로 지원하지 않는 언어나, 다른 라이브러리를 가져와서 사용하게 되는 경우에 메타프로그래밍을 통해 원하는 기능들로 매핑해서 사용하면 편리하다. swift에서는 extension을 활용하면 해당 객체나 구조체가 원래 가지고 있던 함수처럼 사용할 수 있다.extension Reactive where Base: UILabel { /// Bindable sink for `text` property. public var text: Binder&lt;String?&gt; { return Binder(self.base) { label, text in label.text = text } } /// Bindable sink for `attributedText` property. public var attributedText: Binder&lt;NSAttributedString?&gt; { return Binder(self.base) { label, text in label.attributedText = text } }}위의 예제는 RxSwift/RxCocoa/iOS/UILabel+Rx.swift에서 가져온 것인데 기존의 UILabel을 함수형 개념으로 사용할 수 있도록 도와준다. 여기서 만들어서 사용한 것 처럼 진행하고 있는 프로젝트의 방향성에 맞게 확장해서 사용가능 하다는 장점이 있다.정리 함수형 프로그래밍이 객체지향 프로그래밍과 완전히 등을 돌리고 있는것이 아니라는 것을 알았다. 사이드 이팩트가 많이 발생할 수 있는 부분에 함수형을 적용하면 좋다는 것을 알았다. 런타임에 양도하는 것이 중요한 개념이라는 것을 알게 되었다. swift를 사용하면서 이미 많은 개념들을 함수형으로 사용하고 있다는 것을 알게되었다. 함수형에도 패턴이 있다는 것을 알게 되었다. 스트림을 무한한 컬렉션이라고 상상해보면 더 이해가 쉽다는 것을 알게되었다. 함수형으로 코드를 작성하는 것은 쉽지 않다. 하지만 제대로 사용하면 더 간결하고 안전한 코드를 얻을 수 있다는 것을 알게되었다." }, { "title": "Memory Deep Dive", "url": "/posts/memory-deep-dive/", "categories": "CS", "tags": "", "date": "2018-09-17 00:00:00 +0000", "snippet": " memory graph malloc_history leaks strong refrence 확인할 수 있음 heap instance의 크기를 알고 싶을 때 Images 메모리 사...", "content": " memory graph malloc_history leaks strong refrence 확인할 수 있음 heap instance의 크기를 알고 싶을 때 Images 메모리 사용은 파일 사이즈가 아닌, 이미지의 dimesion과 관련이 있다. 2048 x 1536 x 4 bytes pixels =&gt; 10MB 메모리 사용 Wide format: 8 bytes / pixel 어떻게 적절한 포맷을 선택할 것인가? UIGraphicsBeginImageContextWithOptions 쓰지말고 UIGraphicsIamgeRenderer 쓰자 iOS 12 에서 이미지에 적합한 포맷을 선택해줌 앱이 백그라운드에 있을 때 여전히 메모리를 사용하고 있음 UIApplicationDidEneterBackground / Foreground 노티를 받아서 unload 하고 load 하는 방법 viewDidDisapper / viewWillAppear 때 이미지를 unload 하고 load 하는 방법 ImageIO downsampling image 를 위해 사용 " }, { "title": "jekyll 테마 적용하기", "url": "/posts/jekyll-theme/", "categories": "jekyll", "tags": "", "date": "2018-09-15 00:00:00 +0000", "snippet": "테마 고르기개발 과정에 대한 기록을 하지 않다보니 어떤 문제를 해결하려 했고, 발견한 것은 무엇인지 제대로 정리가 되지 않는 느낌을 받았다. 이미 사용중인 github pages가 있어서 테마를 조금 바꿔서 활용해보고 싶다는 생각이 들었다. 테마를 바꾸는 이유는 다음과 같다. 블로그 내 글을 검색할 수 있으면 좋겠다 글 목록을 자동으로 리스팅 해주...", "content": "테마 고르기개발 과정에 대한 기록을 하지 않다보니 어떤 문제를 해결하려 했고, 발견한 것은 무엇인지 제대로 정리가 되지 않는 느낌을 받았다. 이미 사용중인 github pages가 있어서 테마를 조금 바꿔서 활용해보고 싶다는 생각이 들었다. 테마를 바꾸는 이유는 다음과 같다. 블로그 내 글을 검색할 수 있으면 좋겠다 글 목록을 자동으로 리스팅 해주면 좋겠다 어두운 계열의 색상이면 좋겠다맘에 드는 테마가 생각보다 별로 없고, 위의 조건에 맞는 것이 하나 있었다. https://github.com/mmistakes/jekyll-theme-basically-basic#skin 그래서 기존에 사용하던 github pages를 어떻게 바꿀 수 있을지 들어가보니 커스터마이징 할 수 있는 폴더 구조가 되어 있지 않았다. 제일 기본 형태라서 그렇게 되어 있는지도 모르겠다. 그래서 jekyll를 설치해서 폴더 구조 부터 잡아보기로 했다.jekyll 설치하기이렇게 친절하게 정리할 수 있을까 싶을 정도로 잘 정리된 글이 있어서 설치는 어렵지 않게 할 수 있었다. https://nolboo.kim/blog/2013/10/15/free-blog-with-github-jekyll/다만 jekyll 을 통해서 프로젝트를 생성하고 나서 jekyll serve --watch 를 통해서 로컬에서 블로그를 확인하려 했는데 잘 되지 않아서 조금 검색을 해봐야했다.$ jekyll serve --watch/System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require': cannot load such file -- bundler (LoadError)\tfrom /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require'\tfrom /Library/Ruby/Gems/2.3.0/gems/jekyll-3.8.3/lib/jekyll/plugin_manager.rb:48:in `require_from_bundler'\tfrom /Library/Ruby/Gems/2.3.0/gems/jekyll-3.8.3/exe/jekyll:11:in `&lt;top (required)&gt;'\tfrom /usr/local/bin/jekyll:22:in `load'\tfrom /usr/local/bin/jekyll:22:in `&lt;main&gt;'이런 에러가 뜬다면 아래의 답변이 도움이 될 것이다.https://github.com/jekyll/jekyll/issues/5165#issuecomment-236341627$ gem install bundler$ bundle install$ bundle exec jekyll serve테마 변경하기이제 기본 테마에서 내가 원하는 테마로 바꿔보자https://github.com/mmistakes/jekyll-theme-basically-basic#installationiOS에서 cocoapods를 통해서 라이브러리를 불러오듯이 아주 간편하게 불러올 수 있었다.다시 한번 $ bundle exec jekyll serve 를 통해 테마가 제대로 적용되었는지 한번 체크해보면 된다.검색https://github.com/mmistakes/jekyll-theme-basically-basic#search_config.yml 파일에서 search: true 를 적어주고 다시 로컬에서 확인해보면 우상단에 검색 버튼이 생긴것을 확인할 수 있다어두운 화면https://github.com/mmistakes/jekyll-theme-basically-basic#skin/_data/theme.yml 을 찾아가서 skin: night 로 바꿔주면 된다고 하는데 _data 폴더를 찾을 수 없어서 직접만들어 줬다.글 목록글 목록은 posts 폴더 안에 형식을 맞춰 적으면 날짜별로 구분해준다. /_posts/yyyy-MM-dd-제목을-써보자.md" }, { "title": "CocoaPods 꿀팁", "url": "/posts/cocoapods-tips/", "categories": "cocoapods", "tags": "", "date": "2018-08-30 00:00:00 +0000", "snippet": "특정 주소의 pod을 타겟으로 바라보기http://guides.cocoapods.org/using/the-podfile.html#from-a-podspec-in-the-root-of-a-library-repoTo use the master branch of the repo:pod 'Alamofire', :git =&gt; 'https://github....", "content": "특정 주소의 pod을 타겟으로 바라보기http://guides.cocoapods.org/using/the-podfile.html#from-a-podspec-in-the-root-of-a-library-repoTo use the master branch of the repo:pod 'Alamofire', :git =&gt; 'https://github.com/Alamofire/Alamofire.git'To use a different branch of the repo:pod 'Alamofire', :git =&gt; 'https://github.com/Alamofire/Alamofire.git', :branch =&gt; 'dev'To use a tag of the repo:pod 'Alamofire', :git =&gt; 'https://github.com/Alamofire/Alamofire.git', :tag =&gt; '3.1.1'Or specify a commit:pod 'Alamofire', :git =&gt; 'https://github.com/Alamofire/Alamofire.git', :commit =&gt; '0f506b1c45'pod이 업데이트 되었는지 확인하기pod outdated입력하면 아래와 같이 버전 정보가 비교되어 나온다. latest version을 보고 필요한 경우 업데이트 해주면 된다.The following pod updates are available:- AFNetworking 2.6.3 -&gt; 2.6.3 (latest version 3.2.1)- SnapKit 4.0.1 -&gt; 4.0.1 (latest version 4.2.0)CocoaPods warning 제거하기 ⚠️1. inhibit_warnings 옵션 적용하기iOS 프로젝트에 오픈소스를 간편하게 가져올 수 있도록 도와주는 cocoapods를 사용하다 보면 warning이 많이 발생하는 것을 볼 수 있다.내가 작성한 코드도 아닌데 warning이 이렇게나 많이 뜨는것은 좀 억울하다는 생각이 들었다.때마침 Xcode 에서 Pod 프로젝트의 경고 표시 없애기 링크가 보이길래 적용해보았다.경고를 무시하고 싶은 pod 파일 뒤에 :inhibit_warnings =&gt; true를 명시 하면 된다는 것이다.pod 'Alamofire', '~&gt; 4.5', :inhibit_warnings =&gt; true마침 FBSDKLoginKit에서 warning이 발생하고 있어서 바로 적용해봤다.음… 잘된다.하지만 새로운 pod이 추가될 때 마다 같은 문구를 반복해서 달아줘야 한다는 것은 아주 귀찮은 일이다.2. 모든 pod에 inhibit_warnings 옵션 적용하기다들 개발자들도 귀찮은 것을 싫어하지 않을까? 싶어서 검색해봤다. https://github.com/ClintJang/cocoapods-tipsinhibit_all_warnings!앞으로 pod이 새롭게 추가되어도 pod 설치시에 위의 스크립트가 돌면서 warning을 만나지 않게 되었다. 🎉타겟별 공통으로 사용되는 pod 파일 묶어주기이건 조금 다른 이슈인데, FBSDKLoginKit 에서 사용하는 코드가 AppExtension 에서는 작동하지 않는다는 것을 알게되었다.UIViewController *vc = [UIApplication sharedApplication].keyWindow.rootViewController.presentedViewController;// FBLogin 'sharedApplication' is unavailable: not available on iOS (App Extension) - Use view controller based solutions where appropriate instead.타겟별로 분리하지 않았기 때문에 이런 이슈가 발생했다.그렇다고 해서 이렇게 무식하게 하나만 빼고 전부 복붙을 할 수는 없는 노릇이다.target 'sieum' do shared_pods # Pods for sieum pod 'FBSDKLoginKit' # 이것만 다르다 pod 'SnapKit', '~&gt; 4.0.0' pod 'Firebase/Core' pod 'Firebase/Database' pod 'DBImageColorPicker', '~&gt; 1.0.0' pod 'Alamofire', '~&gt; 4.3' pod 'SwiftyBeaver' pod 'PopupDialog', '~&gt; 0.5' pod 'SwiftyJSON' pod 'Kingfisher', '~&gt; 4.0' pod 'SHSideMenu', '~&gt; 0.0.4' pod 'RxDataSources', '~&gt; 3.0' pod 'RxTheme', '2.0' pod 'Then' pod 'ObjectMapper', '~&gt; 3.3'endtarget 'SieumWidget' do pod 'SnapKit', '~&gt; 4.0.0' pod 'Firebase/Core' pod 'Firebase/Database' pod 'DBImageColorPicker', '~&gt; 1.0.0' pod 'Alamofire', '~&gt; 4.3' pod 'SwiftyBeaver' pod 'PopupDialog', '~&gt; 0.5' pod 'SwiftyJSON' pod 'Kingfisher', '~&gt; 4.0' pod 'SHSideMenu', '~&gt; 0.0.4' pod 'RxDataSources', '~&gt; 3.0' pod 'RxTheme', '2.0' pod 'Then' pod 'ObjectMapper', '~&gt; 3.3'end그래서 공통으로 쓰이는 부분은 shared_pods로 묶고,특정 타겟에서 필요한 것만 정의해서 쓰는 방법을 사용했다.def shared_pods use_frameworks! pod 'SnapKit', '~&gt; 4.0.0' pod 'Firebase/Core' pod 'Firebase/Database' pod 'DBImageColorPicker', '~&gt; 1.0.0' pod 'Alamofire', '~&gt; 4.3' pod 'SwiftyBeaver' pod 'PopupDialog', '~&gt; 0.5' pod 'SwiftyJSON' pod 'Kingfisher', '~&gt; 4.0' pod 'SHSideMenu', '~&gt; 0.0.4' pod 'RxDataSources', '~&gt; 3.0' pod 'RxTheme', '2.0' pod 'Then' pod 'ObjectMapper', '~&gt; 3.3'endtarget 'sieum' do shared_pods # Pods for sieum pod 'FBSDKLoginKit'endtarget 'SieumWidget' do shared_podsend완벽하진 않지만 이제야 좀 정리된 것 같다." }, { "title": "What's New in Testing", "url": "/posts/WWDC-What's-New-in-Testing/", "categories": "swift", "tags": "", "date": "2018-08-25 00:00:00 +0000", "snippet": "What’s New in TestingWWDC 영상 보면서 정리했습니다.https://developer.apple.com/videos/play/wwdc2018/403/Code coveragePerformance 로딩 시간: XCode9 에서 6.5초 걸리던 것이 XCode9.3에서는 0.3초 걸린다. coverage 파일 사이즈: XCode9에서 ...", "content": "What’s New in TestingWWDC 영상 보면서 정리했습니다.https://developer.apple.com/videos/play/wwdc2018/403/Code coveragePerformance 로딩 시간: XCode9 에서 6.5초 걸리던 것이 XCode9.3에서는 0.3초 걸린다. coverage 파일 사이즈: XCode9에서 214MB -&gt; XCode9.3에서 18.5MB C++ header 파일의 Code coverage도 측정해서 통과되지 못한 코드에 빨간색으로 표시해준다.Target Selection Code coverage 옵션을 enabled/disabled 로 설정해줄 수 있다.xconv 커멘드 라인 툴 결과물: 사람이 읽을 수 있음, 기계가 읽을 수 있도록 파싱가능(JSON) coverage data를 볼 수 있음Coverage Datacoverage data가 enabled된 상태로 테스트를 수행하게 되면 XCode는 두개의 파일을 생성한다. Coverage report각 타겟, 소스파일, 함수의 line coverage 퍼센트를 포함한다. Coverage archive리포트의 각 파일에 대한 Raw execution counts를 포함한다. Coverage Data는 프로젝트의 derived data 디렉토리 안에 있게 된다.추가적으로 result bundle path flag를 설정해주면 해당 번들에 Coverage data 파일들이 위치하게 된다. 각 파일, 각 메소드에 대한 coverage를 확인할 수 있다. 그리고 설정을 통해 같은 결과를 JSON 형태로 받아볼 수 있다.Source Editor앞에서는 커멘드 라인에서 확인하는 법을 소개했는데, 실제로 사용할 때는 XCode에서 보븐 것이 편할 것이다. Menu &gt; Editor &gt; Show Code Coverage를 통해 활성화 시킬 수 있다. 테스트를 통과하지 못한 코드는 빨간색으로 표시된다.Test selection and ordering모든 테스트가 동일한 목적을 가지지 않는다. 당신은 아마도 빨리 검증될 수 있는 1000개의 유닛 테스트를 실행하고 오랜 시간이 걸리는 UI 테스트를 진행하고 싶을 것이다.이제 scheme에서 특정 테스트를 disable 해서 스킵할 수 있다. 스킴은 disable된 테스트의 리스트를 인코딩해서 XE Test가 어떤 테스트를 스킵할 것인지 선택할 수 있게한다. 그리고 이것이 흥미로운 사이드 이펙트를 만들어낸다. 새로운 테스트를 작성할 때 마다, 테스트 타겟에 해당하는 모든 스킴에 추가된다. 하지만 그걸 원하지 않는다면, 모든 스킴들을 확인하면서 테스트를 수동으로 disable 시켜야한다(잘안써봐서 모르지만 하나하나 노가다로 꺼야 했는듯ㅜ…)Test Selection그래서 XCode10 테스트를 인코딩하는 새로운 모드를 제공한다. 스킴을 새로운 모드로 전환하면, 선택한 테스트가 해당 스킴에서만 작동한다. 이 모드는 스킴 에디터(Product &gt; Scheme &gt; Edit Scheme)에서 Test 섹션을 누르고 해당 스킴의 옵션으로 선택할 수 있다. Automatically include new tests를 on/off할 수 있다. 이렇게하면 일부 스킴들은 새로 작성된 테스트들을 포함해서 실행하게 되고, 또 다른 스킴들은 직접 선택한 테스트들만 실행한다.Test Ordering지금까지 어떤 테스트를 언제 실행할지에 대해 논의 했다. 하지만 테스트 순서도 중요할 수 있다. 기본적으로, XCode의 테스트는 이름 순으로 정렬된다. (이름을 바꾸지 않으면 항상 같은 순서로 실행됨) 하지만 이와 같은 결정방식은 양날의 검이 될 수 있다.단점하나의 테스트가 다른 테스트에 암묵적으로 종속성을 가질 때, 순서대로 작동하는 테스트는 버그들을 놓칠 수 있다.A, B, C 라는 테스트가 항상 동일한 순서로 작동한다고 가정하자. A에서 DB를 생성하고, C에서 삭제한다.만약 이름이 변경되어서 순서가 바뀌게 되면 테스트는 실패하게 된다.이런 문제를 방지하기 위해서 테스트는 항상 올바르게 setup 되고 tearDown되어야 한다.해결책 XCode10에서는 test randomization mode를 제공한다. 모드를 활성화하면 테스트를 실행할 때마다 순서를 섞는다. 스킴 에디터에서 Randomize execution order를 on/off 해주면 된다.Parallel testing 일반적인 개발 프로세스: Write -&gt; Debug -&gt; Test -&gt; Push (다시반복) 테스트가 얼마나 걸리는지 따라 병목 현상 발생함 Xcode8: 순차적 진행. iPhoneX에서 실행하고 iPad에서 실행하라고 하면, iPhoneX 에서 테스트가 끝나고 나서 iPad에서 테스트를 진행한다. XCode9: Parallel Destination Testing을 소개했었다. 여러 기기에서 동시에 테스트를 할 수 있다.한계 multiple destination에 대해서만 이점이 있다. xcodebuild에서만 접근이 가능하다. CI 환경에서만 이점이 있다.해결책: Parallel Distributed Testing 단일 destination 에서 테스트를 병렬로 실행할 수 있다. XCode 와 xcodebuild 모두 접근가능하다." }, { "title": "Builder 패턴 사용하기", "url": "/posts/ExtendingVariablesAndUsingBuilderPattern/", "categories": "swift", "tags": "", "date": "2018-08-16 00:00:00 +0000", "snippet": "JSONWebToken.swift를 통해서 본 variable 확장하기, builder 패턴 사용하기JSONWebToken.swift readme 파일을 한번 살펴보다가 흥미로운 코드를 발견했다.class의 variable을 계속해서 확장하게 만들 수 있을까?var claims = ClaimSet()claims.issuer = \"fuller.li\"cl...", "content": "JSONWebToken.swift를 통해서 본 variable 확장하기, builder 패턴 사용하기JSONWebToken.swift readme 파일을 한번 살펴보다가 흥미로운 코드를 발견했다.class의 variable을 계속해서 확장하게 만들 수 있을까?var claims = ClaimSet()claims.issuer = \"fuller.li\"claims.issuedAt = Date()claims[\"custom\"] = \"Hi\"JWT.encode(claims: claims, algorithm: .hs256(\"secret\".data(using: .utf8)!))claims[\"custom\"] 으로 variable을 추가하는 모습을 볼 수 있다.내부적으로는 class안에 dictionary를 두고 모든 variable을 담아뒀기 떄문에 이렇게 무한대로 확장 가능한 것이다.public struct ClaimSet { var claims: [String: Any] public init(claims: [String: Any]? = nil) { self.claims = claims ?? [:] } public subscript(key: String) -&gt; Any? { get { return claims[key] } set { if let newValue = newValue, let date = newValue as? Date { claims[key] = date.timeIntervalSince1970 } else { claims[key] = newValue } } }}subscript를 구현했기 때문에 class를 dictionary 처럼 직접적으로 사용할 수 있다.extension ClaimSet { public var issuer: String? { get { return claims[\"iss\"] as? String } set { claims[\"iss\"] = newValue } } public var audience: String? { get { return claims[\"aud\"] as? String } set { claims[\"aud\"] = newValue } }}그리고 public 으로 보여지는 변수들도 사실은 dictionary에 담겨 있도록 설계되어 있다.아주 많은 확장성을 가져야할 때 이렇게 작성하는 방법도 있다는 것을 배울 수 있다.클로저로 Builder 넘겨주기readme 파일 위의 예제 바로 밑에 또 흥미로운 코드가 있었다.Builder 패턴을 어떻게 사용하면 좋을까 고민하고 있었는데, 나중에 참고하면 좋을 것 같다.클로저로 builder를 넘겨주는 방식이다.사용하는 쪽에서 builder을 init할 필요 없고 클로저 안에서 바로 사용하기만 하면 되기 때문에 간편하고 코드를 읽을 때에도 주변 코드와 잘 분리될 수 있을 것 같다.JWT.encode(.hs256(\"secret\".data(using: .utf8))) { builder in builder.issuer = \"fuller.li\" builder.issuedAt = Date() builder[\"custom\"] = \"Hi\"}내부 구현은 다음과 같다. 여기에서 직접 builder를 생성해서 closure에 담아서 넘겨준다.사용하는 쪽에서 builder에 원하는 작업을 했을 것이고,그 builder를 가지고 encode하는 방식이다.public func encode(_ algorithm: Algorithm, closure: ((ClaimSetBuilder) -&gt; Void)) -&gt; String { let builder = ClaimSetBuilder() closure(builder) return encode(claims: builder.claims, algorithm: algorithm)}참고: https://github.com/kylef/JSONWebToken.swift" }, { "title": "estimated height가 작을 때 table view가 튀어오르는 현상", "url": "/posts/tableview-pop-when-estimate-height-is-small/", "categories": "swift", "tags": "", "date": "2018-06-19 00:00:00 +0000", "snippet": "table view에서 estimated height가 row height 보다 작은 경우 reloadData() 할 때 스크롤이 튀어오르는 문제가 있다.scroll offset을 기억해서 조정하는 방법도 있는 듯하지만 근본적인 문제를 해결하는 방법이 아닌것 같아서 다른 방법을 한동안 찾아봤다.제일 처음 table view를 그려줄 때는 이상 없고, ...", "content": "table view에서 estimated height가 row height 보다 작은 경우 reloadData() 할 때 스크롤이 튀어오르는 문제가 있다.scroll offset을 기억해서 조정하는 방법도 있는 듯하지만 근본적인 문제를 해결하는 방법이 아닌것 같아서 다른 방법을 한동안 찾아봤다.제일 처음 table view를 그려줄 때는 이상 없고, reload 될 때부터 문제가 발생한다.그렇다면 cell 이 화면에 그려진 높이를 저장하고, 다음 업데이트 될때 estimated height로 사용하면 table view가 튀어오르는 현상을 해결할 수 있겠다.var cellHeightsDictionary: [IndexPath: CGFloat] = [:]func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { cellHeightsDictionary[indexPath] = cell.frame.size.height}func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat { return cellHeightsDictionary[indexPath] ?? UITableViewAutomaticDimension}https://stackoverflow.com/a/49254704/5761092" }, { "title": "Stack View subview hidden시 constraints 문제", "url": "/posts/Stack-View-constraints/", "categories": "swift", "tags": "", "date": "2018-06-19 00:00:00 +0000", "snippet": "Stack View subview hidden시 constraints 문제stack view에 두 개의 label이 있고 spacing을 설정한 상태에서하나의 label을 hidden 하게 되었을 때 constraints 가 깨졌다는 문구를 볼 수 있다.hidden 시키면 stack view가 친절하게 모든 constraints를 설정해주는 줄 알았는...", "content": "Stack View subview hidden시 constraints 문제stack view에 두 개의 label이 있고 spacing을 설정한 상태에서하나의 label을 hidden 하게 되었을 때 constraints 가 깨졌다는 문구를 볼 수 있다.hidden 시키면 stack view가 친절하게 모든 constraints를 설정해주는 줄 알았는데spacing이 0 이상으로 설정되어 있으면 constraints를 어떻게 변경해줘야 하는지 모호해지는 듯 하다.이를 해결하기 위한 몇가지 방법이 있다. stack view에서 해당 view를 제거한다.아주 난폭한 방법인듯 하다. 해결이 되긴 할 것이다. spacing을 0으로 바꿔준다.간편하긴 하지만 상태가 변했을 때 수동으로 바꿔줘야 한다는 단점이 있다. constraints priority 변경bottom에 해당하는 priority를 변경해줘서 해결한다. https://stackoverflow.com/a/38237833/5761092" }, { "title": "RxSwift 개념잡기", "url": "/posts/RxSwift-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/", "categories": "RxSwift", "tags": "", "date": "2018-06-11 00:00:00 +0000", "snippet": "RxSwift 개념잡기 목표: 스트림 기반 기본 동작에 대한 이해개념 절차형 프로그래밍의 한계: 복잡도가 올라갈 수록 유지보수하기 어려워 진다. 스레드에 따른 결과가 달라진다. 그래서 콜백/리스너 개념을 도입콜백/리스너의 단점 예측 불가능한 순서: 이벤트가 도착하는 순서는 Observer를 등록한 순서에 따라 변경될 수 있음 첫 번째 이벤트...", "content": "RxSwift 개념잡기 목표: 스트림 기반 기본 동작에 대한 이해개념 절차형 프로그래밍의 한계: 복잡도가 올라갈 수록 유지보수하기 어려워 진다. 스레드에 따른 결과가 달라진다. 그래서 콜백/리스너 개념을 도입콜백/리스너의 단점 예측 불가능한 순서: 이벤트가 도착하는 순서는 Observer를 등록한 순서에 따라 변경될 수 있음 첫 번째 이벤트 소실 스레드 문제 콜백 누수: Observer를 해제하는 것을 잊으면 메모리 누수가 발생FRP (functional reactive programming) 선언적 프로그래밍: 개념적으로 어떤 특성이 필요한지 정의. 순차적으로 어떻게 이루어져야 하는지 나열하는 것 보다 효율적. Subject를 오직 정보의 근원으로만 봐야한다. 결코 “이제 여기서 코드가 이 값을 푸시한다”라고 말해서는 안된다. 마음 속에서 그런 생각을 아예 없애버려라. FRP를 사용하려면 개념적인 수준에서 생각하기 위해 노력하라. 여러 요소 간 상호작용의 매커니즘이 아니라 그들 사이의 관계 수준에서 머물러라.참조 투명성 map에 전달하는 함수가 반드시 참조 투명성(referential transparency)을 보장해야 한다. 외부에서 볼 수 있는 변수의 상태를 변경해서는 안된다. 함수 호출과 호출 사이에 지속되는 상태를 유지해서는 안된다. 짧게 말해, 참수는 반환값을 제외한 외부 효과를 만들어서는 안되며, 함수의 반환값이 외부 상태에 의해 영향 받는 일도 없어야 한다.참고: 함수형 반응형 프로그래밍Observable hot observable: 생성되자마자 데이터를 흘려보내는 것 cold observable: subscribe 된 다음 데이터를 흘려보내는 것enum Event&lt;Element&gt; { case next(Element) // next element of a sequence case error(Swift.Error) // sequence failed with error case completed // sequence terminated successfully}class Observable&lt;Element&gt; { func subscribe(_ observer: Observer&lt;Element&gt;) -&gt; Disposable}protocol ObserverType { func on(_ event: Event&lt;Element&gt;)}SubjectObservable + Observer BehaviorSubject: 구독하면 가장 최근 값 가져오기, 구독 이후 반환 값 가져오기 PublishSubject: 구독 이후 반환 값 가져오기 ReplaySubject: 구독 이전 값(버퍼 사이즈에 따라 다름), 구독 이후 값 가져오기상태 관리Rx에서는 상태를 관리하기 위한 메서드 3개와 클래스 1개를 제공한다. scan(): 지정한 초기값으로부터 상태값 누적 withLastestFrom(): 가장 최근의 observable 값 가져오기 combineLatest() BehaviorSubject예제UIButtonhttps://academy.realm.io/kr/posts/how-to-use-rxswift-with-simple-examples-ios-techtalk/func setup() { let reloadButton = UIButton() reloadButton.rx.tap .debounce(0.3, scheduler: MainScheduler.instance) .do(onNext: { print(\"reload button clicked\") }) .bind(onNext: reload) .disposed(by: disposeBag)}func reload() {}UISearchBarlet searchResults = searchBar.rx.text.orEmpty .throttle(0.3, scheduler: MainScheduler.instance) .distinctUntilChanged() .flatMapLatest { query -&gt; Observable&lt;[Repository]&gt; in if query.isEmpty { return .just([]) } return searchGitHub(query) .catchErrorJustReturn([]) } .observeOn(MainScheduler.instance)searchResults .bind(to: tableView.rx.items(cellIdentifier: \"Cell\")) { (index, repository: Repository, cell) in cell.textLabel?.text = repository.name cell.detailTextLabel?.text = repository.url } .disposed(by: disposeBag)" }, { "title": "RxDataSource 예제를 보며 RxSwift 익히기", "url": "/posts/RxSwift-tableview/", "categories": "swift", "tags": "", "date": "2018-06-11 00:00:00 +0000", "snippet": "RxSwift 개념잡기 목표: table view form library를 rx스럽게 작성하기예제RxSwiftRxSwift 프로젝트에 포함된 예제를 먼저 살펴보자SimpleTableViewExampleViewControllertableView.rx .modelSelected(String.self) .subscribe(onNext: { v...", "content": "RxSwift 개념잡기 목표: table view form library를 rx스럽게 작성하기예제RxSwiftRxSwift 프로젝트에 포함된 예제를 먼저 살펴보자SimpleTableViewExampleViewControllertableView.rx .modelSelected(String.self) .subscribe(onNext: { value in DefaultWireframe.presentAlert(\"Tapped `\\(value)`\") }) .disposed(by: disposeBag)tableView.rx .itemAccessoryButtonTapped .subscribe(onNext: { indexPath in DefaultWireframe.presentAlert(\"Tapped Detail @ \\(indexPath.section),\\(indexPath.row)\") }) .disposed(by: disposeBag)배울점 modelSelected는 있는 줄 몰라서 못썼던 부분이다.itemSelected 말고 modelSelected를 바로 사용해서 선택된 모델을 더 손쉽게 가져올 수 있겠다. itemAccessoryButtonTapped cell 안의 요소들의 상태 변화를 이것처럼 가져올 수 있으면 좋겠다.switch on/off를 내가 작성할 때는 configure() 에서 해주게 되어서 코드가 분리되어 보인다.SimpleTableViewExampleSectionedViewController{ tableView.rx .itemSelected .map { indexPath in return (indexPath, dataSource[indexPath]) } .subscribe(onNext: { pair in DefaultWireframe.presentAlert(\"Tapped `\\(pair.1)` @ \\(pair.0)\") }) .disposed(by: disposeBag) tableView.rx .setDelegate(self) .disposed(by: disposeBag)}// to prevent swipe to delete behaviorfunc tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCellEditingStyle { return .none}func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat { return 40}배울점 itemSelected를 바로 사용하지 않고 한번 더 map 해서 가공 setDelegate를 통해서 table view의 delegate를 사용한다. 딱히 뾰쪽한 수는 없나보다.rx_tap on UIButton of UITableViewCellhttps://github.com/ReactiveX/RxSwift/issues/288class TableViewCell: UITableViewCell { var disposeBag = DisposeBag() let subject = PublishSubject&lt;Void&gt;() override func prepareForReuse() { disposeBag = DisposeBag() } @IBAction onSomeTableViewCellViewAction(_ sender: AnyObject){ subject.onNext(()) }}// then when you dequeue for reuse from the UITableViewDataSourcelet item = tableView.dequeue...item.subject .asObservable() .subscribe(onNext: {...}) // put it in the items disposeBag so when it's reused it will be cleared .disposed(by: item.disposeBag)배울점 기존 방법과 같이 prepareForReuse 호출될 때 disposeBag 갱신해주면 됨 다만 PublishSubject를 protocol이나 다른 요소로 통일해서 tableview bind 하는 부분에서 같이 처리해줄 수 있으면 좋겠다. SimpleTableViewExampleViewController의 2번 배울점에서 나온 것 처럼 tableview.rx.itemChanged() 같이 받을 수 있으면 좋겠다. 내용을 보면 delegate 를 rx로 받을 수 있게 한번 래핑한 것처럼 보이는데, cell에 적용할 수 있는 방법을 생각해보자. delegate proxyRxSimpleDataSource// MARK: - Reactive Extensionsextension Reactive where Base: PersonCell { var tappedButton: Observable&lt;Bool&gt; { guard let cellType = base.cellType else { return .never() } return base.btnActive .rx.tap .map { !cellType.isActive } }}private func setupDataSource(dataSource: TableViewSectionedDataSource&lt;PeopleViewModel.Section&gt;, tableView: UITableView, indexPath: IndexPath, cellType: PersonCell.CellType) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"PersonCell\", for: indexPath) as? PersonCell ?? PersonCell() cell.configureWith(cellType: cellType) cell.rx.tappedButton .map { (cellType.person, $0) } .bind(to: viewModel.inputs.switchedPerson) .disposed(by: cell.disposeBag) return cell}// PeopleViewModel.swiftsections = Observable .combineLatest(people, switchedPerson.startWith(nil)) { ($0, $1?.0, $1?.1) } .map { people, switchedPerson, switchedState -&gt; [Section] in let cells = people.map { person -&gt; PersonCell.CellType in guard let switchedState = switchedState, let switchedPerson = switchedPerson, person == switchedPerson else { return .inactive(person) } return switchedState ? .active(switchedPerson) : .inactive(switchedPerson) } return [Section(model: \"\", items: cells)] } .asDriver(onErrorJustReturn: [])배울점 Reactive에 extension으로 확장하여 사용하는 부분에서 cell.rx 로 좀 더 명확하게 observable인 것을 알 수 있다. data source를 만들어 주는 부분에서 bind를 통해서 delegate 패턴으로 구현하는 대신, 스트림을 연결해주는 것을 볼 수 있다. 연결된 스트림은 combineLatest로 section과 한 곳에 묶여서 상태값을 변환해 줄 수 있다. 2번과 같이하면 한계가 있는데, 지금까지 변해온 상태값이 쌓이지 않는다는 것이다. 코드를 실행해보면 선택된 셀에 대해 업데이트 되고 나머지 셀은 다시 해제됨을 알 수 있다. combineLatest 사용했기 때문에 people에 해당하는 값이 바뀔 때 바로 반영할 수 있다. sections에 대한 Observable만 만들어두고, tableview에 bind 할 때는 이것을 가져다가 쓰면 되기 때문에 코드를 좀 더 분리할 수 있어보인다. 어쩌면 코드를 봐야하는 위치가 두곳으로 분리되기 때문에 단점이라고 볼 수 도 있겠다.RxDataSourceObservable.of(addCommand, deleteCommand, movedCommand) .merge() .scan(initialState) { (state: SectionedTableViewState, command: TableViewEditingCommand) -&gt; SectionedTableViewState in return state.execute(command: command) } .startWith(initialState) .map { $0.sections } .share(replay: 1) // replay를 왜 하지...? .bind(to: tableView.rx.items(dataSource: dataSource)) .disposed(by: disposeBag)배울점 merge 와 combineLatest 의 차이를 알아볼 필요가 있겠다. initialState를 scan해줌으로 현재까지 진행된 상태값 위에 올릴 수 있게 된다. scan을 하는 것은 반응형 프로그래밍의 지향점을 위해서 반드시 사용해야 하는 개념이다. 상태값을 따로 저장하지 않고, 어떤 흐름에서 요청하던지 같은 결과값을 내어줄 수 있어야하기 때문이다." }, { "title": "Associated Types", "url": "/posts/associatedType/", "categories": "swift", "tags": "", "date": "2018-02-28 00:00:00 +0000", "snippet": "요약 asscociatedtype은 protocol에서 구체적인 type을 정하지 않고 해당 프로토콜을 따르는 곳에서 type을 지정할 수 있도록 하는 keyword 이다. 프로토콜을 따르는 곳에서는 typealias로 구체적인 type을 지정할 수 있다.정의프로토콜을 정의할 때 associatedType을 쓰는 것이 유용할 때가 있다. Assoc...", "content": "요약 asscociatedtype은 protocol에서 구체적인 type을 정하지 않고 해당 프로토콜을 따르는 곳에서 type을 지정할 수 있도록 하는 keyword 이다. 프로토콜을 따르는 곳에서는 typealias로 구체적인 type을 지정할 수 있다.정의프로토콜을 정의할 때 associatedType을 쓰는 것이 유용할 때가 있다. Associated type은 프로토콜의 일부가 되는 타입의 placeholder name을 제공한다. 알쏭달쏭하다. typealias와 어떻게 다른거지?Associated type으로 사용되기 위한 실제 type은 프로토콜이 채택되기 전까지는 구체화 되어 있지 않다. associatedtype이라는 키워드를 통해 사용된다.예시protocol Container { associatedtype Item mutating func append(_ itme: Item) var count: Int { get } subscript(i: Int) -&gt; Item { get }} append(_:) method를 통해 새로운 item을 추가할 수 있어야 한다. count프로퍼티를 통해 컨테이너에 있는 item개수를 Int로 반환받을 수 있어야 한다. subscript(i:)를 통해 Int 인덱스에 해당하는 item을 가져올 수 있어야 한다.이 프로토콜에서 각 기능을 구체적으로 어떻게 수행해야하는지 나와있지는 않다. Container를 구성하기 위해 어떤 타입과 함수가 필요한지 정의한다. 그냥 프로토콜에 대한 전반적인 얘기인듯Container 프로토콜을 따르는 타입은 그것이 저장하고 있는 타입을 명확히 할 수 있어야 한다. 뭔말이지특별히, container에 add 되는 것이 올바른 타입이라는 것을 보장할 수 있어야 한다. 그리고 subscript를 통해서 가져온 item의 type도 명확해야 한다.이러한 요구사항을 충족시키기 위해, Container 프로토콜은 Item 으로 불리는 associatedtype을 정의했다. 프로토콜은 Item이 무엇인지 정의하지 않았다. - 이것은 프로토콜을 따르는 쪽의 몫이다.그럼에도 불구하고, Item alias는 Container안에 있는 item의 type을 언급할 수 있는 방법이 있다. 그리고 appned(_:) 메소드에서 쓰일 type을 정의할 수 있고, Container가 작동하기 기대하는 대로 강제할 수 있다.아래는 Container 프로토콜을 따르는 generic이 아닌 버전의 IntStack 이다.struct IntStack: Container { // original IntStack implementation var items = [Int]() mutating func push(_ item: Int) { items.append(item) } mutating func pop() -&gt; Int { return items.removeLast() } // conformance to the Container protocol typealias Item = Int mutating func append(_ item: Int) { self.push(item) } var count: Int { return items.count } subscript(i: Int) -&gt; Int { return items[i] }}출처: https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html" }, { "title": "iOS 메모리 관리", "url": "/posts/Memory-management/", "categories": "swift", "tags": "", "date": "2017-12-29 00:00:00 +0000", "snippet": "1. 레퍼런스 카운트기본 개념 참조하고 있는 객체의 카운트를 1 올려준다. (retain: 보존하다) 더 이상 사용하지 않으면 카운트를 1 내려준다. (release) 카운트가 0이 되면 객체가 해제된다. (dealloc)자동 해제NSAutoreleasePool 다양한 객체의 메모리를 하나하나 관리하기 어렵다. autorelease 메세지를 ...", "content": "1. 레퍼런스 카운트기본 개념 참조하고 있는 객체의 카운트를 1 올려준다. (retain: 보존하다) 더 이상 사용하지 않으면 카운트를 1 내려준다. (release) 카운트가 0이 되면 객체가 해제된다. (dealloc)자동 해제NSAutoreleasePool 다양한 객체의 메모리를 하나하나 관리하기 어렵다. autorelease 메세지를 보내두면, pool이 release될 때 등록된 인스터들 모두에게 release 메세지를 전달하게 된다. retain 횟수와 autorelease 횟수가 동일해야 문제가 발생하지 않는다. pool 자체에 autorelease를 보내면 안된다. 비정상 종료된다. while(...) {id pool = [[NSAutoreleasePool alloc] init];// 여기서 작업 수행[pool release];} 이벤트 풀 Cocoa의 GUI 이벤트 관리는 NSApplication 이라는 클래스가 이벤트 루프를 관리. 각 루프 마다 autoreleasePool을 만들고 루프가 종료되면 해제함. Cocoa의 GUI를 사용해서 개발할 때는 자동 해제 신경쓰지 않아도 됨.오너쉽 정책 자연스럽게 인스턴스 객체의 오너와 해제에 대한 이슈가 발생 객체의 오너가 되는 경우 alloc…을 사용한 인스턴스 생성 copy…를 사용한 인스턴스의 복사: 메세지를 보낸 객체가 복사된 인스턴스의 오너 retain을 사용한 보존- (void)setMyValue:(id)obj{ [obj retain]; [myValue release]; myValue = obj;} 위의 예제에서 retain 하는 순서가 중요 obj와 myValue가 동일한 객체 참조하고 있다면 release를 먼저하면 객체가 해제될 수 있음보존의 순환 - Retain cycleid A = [[MyClass alloc] init];id B = [[MyClass alloc] init];[A setMyValue: B];[B setMyValue: A];[A release];[B release]; release 하더라도 여전히 retain count가 1- (void)dealloc { [myValue release]; [super dealloc];} dealloc 내부에서 release 하면 무한 루프에 빠짐해제되지 않는 인스턴스 retain, release를 오버라이드 해서 아무것도 하지 않도록 함 retainCount를 오버라이드 해서 UNIT_MAX를 리턴하게 함 일반적인 프로그래밍에서 직접 구현하는 경우는 없음 NSApplication, 컬러 패널, 프론트 패널 등… singleton으로 사용됨 shared로 시작하는 클래스 메소드가 공유되는 유일한 인스턴스를 리턴2. ARC- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;Objc는 ARC가 적용된 이후엔 struct 내부에 클래스 타입을 사용하지 못하도록 금지typedef struct ImageNames { NSString *normalImageName; NSString *selectedImageName;} sImageNames;출처: http://minsone.github.io/mac/ios/how-to-use-struct-with-arc-in-objective-cautoreleasepool 블록 블록 내에 생성된 모든 객체는 오토릴리스 됨 블록이 종료될 때 자동으로 파괴 됨 for (i = 0; i &lt; n; ++i){@autoreleasepool{ ... // 여기서 많은 수의 임시 객체를 처리한다.}} @property 지정 옵션 메서드명 지정 getter = 게터명 setter = 세터명읽기/쓰기 속성 readonly: 읽기 전용 readwrite: 읽기/쓰기 가능(기본 값)프로퍼티 속성(값 설정 방법) assign: deallocated 되면 nil이 대입되지 않음. 참조할 시 dangling pointer.(기본값) retain: 새로운 객체를 대입하면 무조건 retain 됨. 순환 참조 발생하면 메모리 해제 불가능.(기본값) unsafe_unretained: (ARC용) assign과 동일. iOS 4 이하에 사용. weak: (ARC용) deallocated 되면 자동으로 nil이 대입됨. nil이 대입된다는 점에서 assign과 다름. 순환 참조를 막기 위해 delegate들에는 weak을 사용. strong: (ARC용) retain과 동일 copy: 복제를 만들어서 설정. 프로퍼티 클래스가 NSCopying 채용하고 copy 메서드 이용할 수 있느때만 사용가능.https://www.letmecompile.com/arc-관련-키워드-사용법/https://soulpark.wordpress.com/2013/04/03/ios-automatic-reference-counting-arc/https://stackoverflow.com/questions/9859719/objective-c-declared-property-attributes-nonatomic-copy-strong-weakhttps://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-13. Copy copy와 mutableCopy 메서드4. Atomic" }, { "title": "memory counting", "url": "/posts/Memory-counting/", "categories": "swift", "tags": "", "date": "2017-12-28 00:00:00 +0000", "snippet": "1. strong을 사용하는 경우 내가 정의하는데 중요하다고 참조를 보장해야 하는 경우와 IB에서 아웃렛(IBOutlet)을 연결하는 경우(컨트롤변수, IBOutlet) 메인뷰는 strong을 기본(recommand)으로 잡아준다ex) XXXAppDelegate.h@property (strong, nonatomic) UIWindow *window;@...", "content": "1. strong을 사용하는 경우 내가 정의하는데 중요하다고 참조를 보장해야 하는 경우와 IB에서 아웃렛(IBOutlet)을 연결하는 경우(컨트롤변수, IBOutlet) 메인뷰는 strong을 기본(recommand)으로 잡아준다ex) XXXAppDelegate.h@property (strong, nonatomic) UIWindow *window;@property (strong, nonatomic) BIDViewController *viewController;ex) XXXViewController.h@property (weak, nonatomic) IBOutlet UIView * backView;##2. weak를 사용하는 경우 내가 정의하는데 중요하다고 참조 보장할 필요가 없는 경우와 IB에서 아웃렛(IBOutlet)을 연결하는 경우(컨트롤변수,  IBOutlet) 하위뷰는 weak를 기본(recommand)으로 잡아준다 보통, delegate는 weak로 지정한다. weak로 사용하는 이유는 이미 참조유지(retain)하고 있을지도 모르는 델리게이트를 실수로 참조 유지하는 일이 없게 하기 위해서다. 만일 해당 델리게이트가 객체의 참조를 유지하지 않는다는 사실을 이미 알고 있다고 하더라도 코코아 터치에서 사용하는 표준 패턴에서는 델리게이트 참조를 유지하지 않으므로 구태여 다른 방식을 사용할 필요는 없을 것 같다.ex) XXXViewController.h@property (weak, nonatomic) IBOutlet UITextField *nameField;@property (weak, nonatomic) IBOutlet UILabel *sliderLabel;@property (weak, nonatomic) IBOutlet UISwitch *leftSwitch;@property (weak, nonatomic) id delegate;3. copy를 사용하는 경우 테이블뷰에서 셀을 하위뷰로 잡아서 사용하는 경우, 저장 NSString값의 경우(변경가능성이 있을 때), 값을 안정적으로 보관해서 받을 때 보통, NSString이나, NSDictionary처럼 값 기반의 클래스를 다룰 때 사용 NSNumber, NSArray, NSSet과 같은 immutable 한 클래스에도 적용되는 개념이다.ex) XXXTableViewCell@interface XXXTableViewCell : UITableViewCell@property (copy, nonatomic) NSString *name;@property (copy, nonatomic) NSString *color;@property (copy, nonatomic) NSDictionary *selection;@end 컨트롤러에서 각 셀로 값을 넘겨줄 때 사용할 두 속성을 정의할 때, NSString속성을 strong으로 사용해 정의하지 않고 copy를 사용해 정의했다. 속성의 세터로 전달된 문자열값은 값을 전달한 코드에서 나중에 값을 수정할 수 있는 NSMutableString이 될 수도 있으므로, 항상 이렇게 NSString값을 정의하는 것이 좋다. 속성으로 전달된 각 문자열을 복사하면 세터가 호출된 순간에 문자열에 들어 있는 값을 안정적으로 속성에 보관할 수 있다.보충설명수정할 수 문자열인 가능성이 있을 때, (수정가능한 하위클래스를 비롯해) 모든 NSString에 대해 copy를 호출하면 항상 수정할 수 없는 복사본이 반환된다. 더불어 성능에 대한 부담도 걱정하지 않아도 된다. 수정할 수 없는 문자열 인스턴스에 대해 copy메세지를 보내면 실제로 복사하 일어나는 것이 아니라 대신 참조 카운트를 증가시킨 후 같은 문자열 객체를 반환한다. 이와같이 copy를 사용하면 객체가 변하지 않을 뿐더러 누구든 문자열 객체를 안심하고 사용할 수 있다. 하지만 제대로 이해가 되지 않는다. NSString과 copy에 대한 예시를 다시 한번 보자.NSString properties를 strong으로 설정한 경우@interface Book: NSObject@property (strong, nonatomic) NSString *title;@end- (void)stringExample { NSMutableString *bookTitle = [NSMutableString stringWithString:@\"Best book ever\"]; Book *book = [[Book alloc] init]; book.title = bookTitle; [bookTitle setString:@\"Worst book ever\"]; NSLog(@\"book title: %@\", book.title); // \"book title: Worst book ever\"}NSString properties를 copy로 설정한 경우@interface Book: NSObject@property (copy, nonatomic) NSString *title;@end- (void)stringExample { NSMutableString *bookTitle = [NSMutableString stringWithString:@\"Best book ever\"]; Book *book = [[Book alloc] init]; book.title = bookTitle; [bookTitle setString:@\"Worst book ever\"]; NSLog(@\"book title: %@\", book.title); // \"book title: Best book ever\"}출처 http://funnyrella.blogspot.kr/2013/10/46_31.html http://www.ios-blog.co.uk/tutorials/quick-tips/use-copy-for-nsstring-properties/" }, { "title": "iOS zPosition", "url": "/posts/zposition/", "categories": "swift", "tags": "", "date": "2017-12-26 00:00:00 +0000", "snippet": "iOS에서 zPosition을 변경해서 UI로 확인할 때는 뒤에 가있는 것으로 보이는데, 실제로 터치했을 때 우선순위가 여전히 앞서 있어서 뒤에 있는 뷰가 터치되는 현상이 발생했다. zPosition을 변경해서 뒤에 있는 것으로 보이게 할 때는 이러한 오류가 발생할 수 있음을 염두해두고 작업하자. 아래는 플레이그라운드에서 테스트하면서 썼던 예제 코드이...", "content": "iOS에서 zPosition을 변경해서 UI로 확인할 때는 뒤에 가있는 것으로 보이는데, 실제로 터치했을 때 우선순위가 여전히 앞서 있어서 뒤에 있는 뷰가 터치되는 현상이 발생했다. zPosition을 변경해서 뒤에 있는 것으로 보이게 할 때는 이러한 오류가 발생할 수 있음을 염두해두고 작업하자. 아래는 플레이그라운드에서 테스트하면서 썼던 예제 코드이다.//: Playground - noun: a place where people can playimport Foundationimport UIKitimport PlaygroundSupportclass ContainerView: UIView { @objc func onHeaderButton() { print(\"header\") } @objc func onMainButton() { print(\"Main\") }}let containerView = ContainerView(frame: CGRect(x: 0, y: 0, width: 300, height: 600))containerView.backgroundColor = UIColor.whitelet headerButton = UIButton(frame: CGRect(x: 0, y: 0, width: 300, height: 500))headerButton.backgroundColor = UIColor.greenheaderButton.layer.zPosition = -1headerButton.addTarget(containerView, action: #selector(containerView.onHeaderButton), for: .touchUpInside)let mainButton = UIButton(frame: CGRect(x: 0, y: 100, width: 300, height: 500))mainButton.backgroundColor = UIColor.bluemainButtonmainButton.addTarget(containerView, action: #selector(containerView.onMainButton), for: .touchUpInside)containerView.addSubview(mainButton)containerView.addSubview(headerButton)PlaygroundPage.current.liveView = containerViewPlaygroundPage.current.needsIndefiniteExecution = true" }, { "title": "swift dynamic", "url": "/posts/Swift-dynamic/", "categories": "swift", "tags": "", "date": "2017-12-26 00:00:00 +0000", "snippet": "dynamicobjc 메세지 호출(메세지 디스패치) 메서드를 호출 하거나 프로퍼티를 참조하는 것 objc 런타임의 동적 바인딩 속성과 관련 호출자가 “메서드 f를 실행” 메세지를 객체에 전송하면 객체는 구현체를 찾아 실행하게 됨 여기서 메서드를 찾는다 는 것이 중요 정적 디스패치의 경우 실행될 구현코드가 고정되어 있음 동적 디스패치의 경...", "content": "dynamicobjc 메세지 호출(메세지 디스패치) 메서드를 호출 하거나 프로퍼티를 참조하는 것 objc 런타임의 동적 바인딩 속성과 관련 호출자가 “메서드 f를 실행” 메세지를 객체에 전송하면 객체는 구현체를 찾아 실행하게 됨 여기서 메서드를 찾는다 는 것이 중요 정적 디스패치의 경우 실행될 구현코드가 고정되어 있음 동적 디스패치의 경우 구현코드를 바꿔치기 할 수 있음 이런 기법을 메서드 스위즐링(swizzling)이라 부름swift dynamic 키워드는 함수나 변수의 선언문에 적용 정적 디스패치 대신 동적 디스패치 를 사용하도록 함 dynamic을 쓰면 자동으로 @objc 어트리뷰트를 추가하게 됨 dynamic 키워드가 적용된 것은 swift 런타임 대신, objc 런타임을 사용하여 메세지 전송사용 용도 앱 분석을 위한 코드를 동적으로 삽입할 때 KVC/KVO에 의존적인 Core Data와 같은 objc 런타임과 효율적인 연동 가능 Objc 에서 오랫동안 사용하던 것들을 swift에 그대로 사용하고 싶을 때 사용출처: https://outofbedlam.github.io/swift/2016/01/27/Swift-dynamic/" } ]
